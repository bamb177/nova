<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>{{ title }}</title>

  <!-- 공통/페이지 CSS 분리 유지 -->
  <link rel="stylesheet" href="/css/select.css?v={{ last_refresh }}" />

  <!-- ✅ Tier 결과 카드 이미지 + PC 폭 확장 오버라이드 -->
  <style>
    /* (2) 전체 페이지 폭 확장 (PC) */
    @media (min-width: 1100px){
      .wrap{ max-width: 1600px !important; }
    }

    /* (1) 등급표 파티 카드: 좌측 초상화 + 이름 */
    .tier-card-top{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .tier-portrait{
      width:44px;
      height:44px;
      border-radius:12px;
      object-fit:cover;
      flex:0 0 auto;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
    }
    .tier-portrait-empty{
      display:block;
    }

    /* (2) 긴 특성명(예: Heikyo Castle) 2줄 방지: 1줄 유지 + 넘치면 말줄임 */
    .tier-card-sub .pill{
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 190px;
    }
  
    /* ✅ Tier 상단 버튼(전체선택/해제) 우측 정렬 */
    .tier-topline{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .tier-topline .tier-actions-inline{
      margin-left:auto;
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:nowrap;
    }
    @media (min-width: 900px){
      .tier-topline{ flex-wrap:nowrap; }
    }

  
    /* Memory Card image (modal) */
    .memcard-wrap{
      display:flex;
      gap:14px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .memcard-img{
      width:128px;
      height:128px;
      border-radius:14px;
      object-fit:cover;
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
    }
    .memcard-img.hidden{ display:none; }
    .memcard-imgcell{
      vertical-align: top;
      padding-top: 10px;
    }

  </style>
</head>

<body>
  <div class="wrap">

    <!-- ===== Topbar ===== -->
    <div class="topbar">
      <div class="title-row">
        <h1>{{ title }}</h1>
        <div class="meta-inline">캐릭터 {{ cache_count }}명</div>
        <div class="refresh">갱신 {{ last_refresh }}</div>
      </div>
    </div>

    {% if error %}
      <div class="error">로딩 오류: {{ error }}</div>
    {% endif %}

    <div class="panel">

      <!-- ===== Filters (Mobile collapsible) ===== -->
      <details id="filtersPanel" class="filters-box" open>
        <summary class="filters-summary">
          <span class="filters-summary-title">검색/필터</span>
          <span class="filters-summary-hint">(열기/닫기)</span>
        </summary>

        <div class="filters-body">
          <div class="filters">
            <input id="q" class="input" type="text" placeholder="검색 (이름/ID/특성/속성)" autocomplete="off" />

            <select id="classFilter" class="select">
              <option value="">클래스(전체)</option>
            </select>

            <select id="rarityFilter" class="select">
              <option value="">등급(전체)</option>
              <option value="SSR">SSR</option>
              <option value="SR">SR</option>
              <option value="R">R</option>
              <option value="-">-</option>
            </select>

            <select id="elemFilter" class="select">
              <option value="">속성(전체)</option>
            </select>

            <select id="factionFilter" class="select">
              <option value="">특성(전체)</option>
            </select>

            <select id="roleFilter" class="select">
              <option value="">역할(전체)</option>
            </select>
          </div>
        </div>
      </details>

      <!-- ===== Tier Party Builder (details: open/close like filters) ===== -->
      <details class="tier-panel" id="tierPanel" open>
        <summary class="tier-summary">
          <span class="tier-summary-title">등급표</span>
          <span class="tier-summary-hint">(열기/닫기)</span>
        </summary>

        <div class="tier-body">
          <div class="tier-row tier-topline">
            <select id="tierPreset" class="select" disabled>
              <option value="">tier-lists.js 로딩중...</option>
            </select>
            <button class="btn" id="btnBuildTierParty" type="button" disabled>등급표로 파티 구성</button>

            <!-- ✅ 전체선택/전체해제: 등급표 상단 우측 정렬 -->
            <div class="tier-actions-inline">
              <button class="btn" id="btnAll" type="button">전체 선택</button>
              <button class="btn" id="btnNone" type="button">전체 해제</button>
            </div>
          </div>

          <div class="tier-row">
            <label class="tier-check" title="체크한 클래스가 파티(4인)에 포함되도록 구성합니다. 후보를 해당 클래스로만 제한하지 않습니다.">
              <input type="checkbox" id="useClassFilter" />
              선택 클래스 포함 조건
            </label>
            <div class="tier-classes" id="tierClassBox" aria-disabled="true"></div>
          </div>

          <div id="tierPartyResult" class="tier-result"></div>
        </div>
      </details>

      <!-- ===== Characters list ===== -->
      <div class="table-wrap">
        <table class="table">
          <thead>
            <tr>
              <th class="col-check">선택</th>
              <th>캐릭터</th>
              <th class="col-elem">속성</th>
              <th class="col-faction">특성</th>
              <th class="col-class">클래스</th>
              <th class="col-role">역할</th>
              <th class="col-rarity">등급</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>

    </div><!-- /.panel -->
  </div><!-- /.wrap -->

  <!-- ===== Modal ===== -->
  <div class="modal-backdrop" id="modalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modal-head">
        <div class="modal-title" id="modalTitle">Character</div>
        <button class="modal-close" id="modalClose" type="button">×</button>
      </div>
      <div class="modal-body" id="modalBody">
        <div class="modal-loading">Loading…</div>
      </div>
    </div>
  </div>

  <script>
    const CHARS_RAW = {{ chars_json|safe }};

    function escapeHtml(str) {
      return (str || "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }

    function pick(obj, ...keys) {
      for (const k of keys) {
        const v = obj?.[k];
        if (v !== undefined && v !== null) return v;
      }
      return null;
    }

    function isEmpty(v) {
      if (v === null || v === undefined) return true;
      if (Array.isArray(v)) return v.length === 0;
      if (typeof v === "object") return Object.keys(v).length === 0;
      if (typeof v === "string") return v.trim() === "";
      return false;
    }

    function slugKey(s){
      return String(s || "")
        .toLowerCase()
        .replace(/[’']/g, "")
        .replace(/[\s\-_]+/g, "")
        .trim();
    }

    const RARITY_ORDER = { "SSR": 3, "SR": 2, "R": 1, "-": 0 };
    function rarityVal(r){
      const x = String(r || "-").toUpperCase();
      return RARITY_ORDER[x] ?? 0;
    }

    function classLabel(cls){
      const v = (cls || "-").toString().trim();
      return v || "-";
    }
    function roleLabel(role){
      const v = (role || "-").toString().trim();
      return v || "-";
    }
    function rarityPillClass(r){
      const v = (r || "-").toString().trim().toUpperCase();
      if (v === "SSR") return "pill-ssr";
      if (v === "SR") return "pill-sr";
      if (v === "R") return "pill-r";
      return "pill-none";
    }

    // ===== Modal rendering (skills/awakenings/memory) =====
    function renderKV(obj) {
      if (!obj || typeof obj !== "object") return `<div class="detail-empty">데이터 없음</div>`;
      const rows = Object.entries(obj).map(([k, v]) => {
        const vv = (typeof v === "object") ? JSON.stringify(v) : String(v);
        return `<tr><td class="kv-k">${escapeHtml(k)}</td><td class="kv-v">${escapeHtml(vv)}</td></tr>`;
      }).join("");
      return `<table class="kv"><tbody>${rows}</tbody></table>`;
    }

    function looksLikeSkillObject(o){
      if (!o || typeof o !== "object" || Array.isArray(o)) return false;
      const keys = ["name","title","skillName","description","desc","text","cooldown","energyCost","cost","type","category"];
      return keys.some(k => o[k] !== undefined && o[k] !== null);
    }

    function normalizeSkillEntry(x, fallbackTitle) {
      if (!x) return { title: fallbackTitle || "-", desc: "", extra: null };

      if (typeof x === "string") {
        return { title: fallbackTitle || "-", desc: x, extra: null };
      }

      if (typeof x === "object") {
        const title =
          (typeof x.name === "string" && x.name) ||
          (typeof x.title === "string" && x.title) ||
          (typeof x.skillName === "string" && x.skillName) ||
          fallbackTitle || "-";

        const desc =
          (typeof x.description === "string" && x.description) ||
          (typeof x.desc === "string" && x.desc) ||
          (typeof x.text === "string" && x.text) ||
          "";

        const extra = {};
        for (const [k, v] of Object.entries(x)) {
          if (["name","title","skillName","description","desc","text"].includes(k)) continue;
          if (v === null || v === undefined) continue;
          if (typeof v === "object") continue;
          extra[k] = v;
        }
        return { title, desc, extra: Object.keys(extra).length ? extra : null };
      }

      return { title: fallbackTitle || "-", desc: String(x), extra: null };
    }

    function renderOneSkillCard(s) {
      const desc = s.desc
        ? `<div class="card-desc">${escapeHtml(s.desc)}</div>`
        : `<div class="card-desc" style="opacity:.75;">(설명 없음)</div>`;
      const extra = s.extra ? renderKV(s.extra) : "";
      return `
        <div class="card">
          <div class="card-title"><span>${escapeHtml(String(s.title || "-"))}</span></div>
          ${desc}
          ${extra ? `<div style="margin-top:8px;">${extra}</div>` : ""}
        </div>
      `;
    }

    function renderSkillCards(skillsObjOrArr) {
      if (isEmpty(skillsObjOrArr)) return `<div class="detail-empty">스킬 데이터 없음</div>`;

      if (looksLikeSkillObject(skillsObjOrArr)) {
        const s = normalizeSkillEntry(skillsObjOrArr, "Skill");
        return `<div class="cards">${renderOneSkillCard(s)}</div>`;
      }

      if (Array.isArray(skillsObjOrArr)) {
        const cards = skillsObjOrArr
          .map((x, idx) => renderOneSkillCard(normalizeSkillEntry(x, `Skill ${idx + 1}`)))
          .join("");
        return `<div class="cards">${cards}</div>`;
      }

      if (typeof skillsObjOrArr === "object") {
        const cards = [];
        for (const [k, v] of Object.entries(skillsObjOrArr)) {
          if (isEmpty(v)) continue;

          if (looksLikeSkillObject(v)) {
            cards.push(renderOneSkillCard(normalizeSkillEntry(v, k)));
            continue;
          }

          if (Array.isArray(v)) {
            for (let i = 0; i < v.length; i++) {
              cards.push(renderOneSkillCard(normalizeSkillEntry(v[i], `${k} ${i + 1}`)));
            }
          }
        }

        if (cards.length === 0) {
          const s = normalizeSkillEntry(skillsObjOrArr, "Skill");
          return `<div class="cards">${renderOneSkillCard(s)}</div>`;
        }
        return `<div class="cards">${cards.join("")}</div>`;
      }

      const s = normalizeSkillEntry(skillsObjOrArr, "Skill");
      return `<div class="cards">${renderOneSkillCard(s)}</div>`;
    }

    function renderSkills(detail) {
      const skills = pick(detail, "skills") || {};
      const teamSkill = pick(detail, "teamSkill", "team_skill", "team");
      const normalData = !isEmpty(skills?.normal) ? skills.normal : skills?.basic;

      const sections = [
        { label: "Auto",       data: skills?.auto,     css: "group-auto" },
        { label: "Ultimate",   data: skills?.ultimate, css: "group-ultimate" },
        { label: "Passive",    data: skills?.passive,  css: "group-passive" },
        { label: "Normal",     data: normalData,       css: "group-normal" },
        { label: "Team Skill", data: teamSkill,        css: "group-team" },
      ];

      return sections.map(s => `
        <div class="group ${s.css}">
          <div class="group-title">${escapeHtml(s.label)}</div>
          ${isEmpty(s.data) ? `<div class="detail-empty">${escapeHtml(s.label)} 데이터 없음</div>` : renderSkillCards(s.data)}
        </div>
      `).join("");
    }

    function normalizeAwakenings(aw) {
      if (!aw) return [];
      if (Array.isArray(aw)) return aw;
      if (typeof aw === "object" && Array.isArray(aw.levels)) return aw.levels;
      return [];
    }

    function awakenRowEffect(x) {
      if (x == null) return "";
      if (typeof x === "string") return x;
      if (typeof x === "number" || typeof x === "boolean") return String(x);
      if (typeof x === "object") {
        const eff = pick(x, "effect", "effects", "desc", "description", "text");
        if (typeof eff === "string") return eff;
        return JSON.stringify(x, null, 2);
      }
      return String(x);
    }

    function renderAwakenings(detail) {
      const aw = pick(detail, "awakenings", "awakening");
      const rows = normalizeAwakenings(aw);
      if (!rows.length) return `<div class="detail-empty">각성 데이터 없음</div>`;

      const tbody = rows.map((x, idx) => {
        const lvl = pick(x, "level", "lv", "stage") ?? (idx + 1);
        const eff = awakenRowEffect(x);
        return `<tr><td style="width:110px;font-weight:950;">Lv.${escapeHtml(String(lvl))}</td><td>${escapeHtml(eff)}</td></tr>`;
      }).join("");

      return `
        <table class="awak-table">
          <thead><tr><th style="width:110px;">레벨</th><th>효과</th></tr></thead>
          <tbody>${tbody}</tbody>
        </table>
      `;
    }

    function renderMemoryCard(detail) {
      const mem = pick(detail, "memoryCard", "memory_card");
      if (isEmpty(mem)) return `<div class="detail-empty">메모리카드 데이터 없음</div>`;
      if (typeof mem !== "object") return `<div class="detail-empty">${escapeHtml(String(mem))}</div>`;

      const name = pick(mem, "name", "title") || "Memory Card";
      const desc = pick(mem, "description", "desc", "text") || "";
      const effects = pick(mem, "effects", "effect");

      let effectsHtml = "";
      if (Array.isArray(effects)) {
        const charName = pick(detail, "name") || "";
        const imgUrl = `/images/games/zone-nova/card/${encodeURIComponent(String(charName))}card.jpg`;

        const effRows = (effects || []).map(e => {
          if (typeof e === "string") return e;
          try { return JSON.stringify(e, null, 2); } catch { return String(e); }
        });

        if (effRows.length === 0) {
          effectsHtml = `<div class="detail-empty">효과 데이터 없음</div>`;
        } else {
          const first = effRows[0];
          const rest = effRows.slice(1);

          const tbody = [
            `<tr>
               <td class="memcard-imgcell" rowspan="${effRows.length}">
                 <img class="memcard-img" src="${imgUrl}" alt="Memory Card"
                      onerror="this.classList.add('hidden');" />
               </td>
               <td>${escapeHtml(first)}</td>
             </tr>`,
            ...rest.map(x => `<tr><td>${escapeHtml(x)}</td></tr>`)
          ].join("");

          effectsHtml = `
            <table class="awak-table">
              <thead><tr><th style="width:160px;">카드</th><th>효과</th></tr></thead>
              <tbody>${tbody}</tbody>
            </table>
          `;
        }
      } else if (effects && typeof effects === "object") {
        effectsHtml = renderKV(effects);
      } else if (typeof effects === "string") {
        effectsHtml = `<div class="card-desc">${escapeHtml(effects)}</div>`;
      } else {
        effectsHtml = renderKV(mem);
      }

      return `
        <div class="card">
          <div class="card-title"><span>${escapeHtml(String(name))}</span></div>
          ${desc ? `<div class="card-desc">${escapeHtml(String(desc))}</div>` : ""}
          <div style="margin-top:10px;">${effectsHtml}</div>
        </div>
      `;
    }

    function renderPanel(id, html, active=false) {
      return `<div class="tab-panel ${active ? "active" : ""}" data-panel="${escapeHtml(id)}">${html}</div>`;
    }

    function renderDetailTabs(detail) {
      const tabs = [
        { id: "skills", label: "스킬", content: renderSkills(detail) },
        { id: "awakenings", label: "각성", content: renderAwakenings(detail) },
        { id: "memory", label: "메모리카드", content: renderMemoryCard(detail) },
      ];
      const firstActive = "skills";

      const tabBtns = tabs.map(t =>
        `<button type="button" class="tab-btn ${t.id === firstActive ? "active" : ""}" data-tab="${escapeHtml(t.id)}">${escapeHtml(t.label)}</button>`
      ).join("");

      const panels = tabs.map(t => renderPanel(t.id, t.content, t.id === firstActive)).join("");
      const raw = `<details class="raw"><summary>Raw JSON 보기</summary><pre>${escapeHtml(JSON.stringify(detail || {}, null, 2))}</pre></details>`;

      return `
        <div class="tabs">
          <div class="tab-bar">${tabBtns}</div>
          <div class="tab-body">${panels}${raw}</div>
        </div>
      `;
    }

    function bindTabEvents() {
      const root = document.getElementById("modalBody");
      if (!root) return;
      root.onclick = (e) => {
        const btn = e.target.closest(".tab-btn");
        if (!btn) return;
        const tab = btn.dataset.tab;
        if (!tab) return;

        root.querySelectorAll(".tab-btn").forEach(b => b.classList.toggle("active", b.dataset.tab === tab));
        root.querySelectorAll(".tab-panel").forEach(p => p.classList.toggle("active", p.dataset.panel === tab));
      };
    }

    // ===== Modal open/close =====
    const backdrop = document.getElementById("modalBackdrop");
    const modalBody = document.getElementById("modalBody");
    const modalTitle = document.getElementById("modalTitle");
    const modalClose = document.getElementById("modalClose");

    function openModal() {
      backdrop.classList.add("show");
      backdrop.setAttribute("aria-hidden", "false");
    }
    function closeModal() {
      backdrop.classList.remove("show");
      backdrop.setAttribute("aria-hidden", "true");
      modalBody.innerHTML = `<div class="modal-loading">Loading…</div>`;
    }
    modalClose.addEventListener("click", closeModal);
    backdrop.addEventListener("click", (e) => { if (e.target === backdrop) closeModal(); });
    document.addEventListener("keydown", (e) => { if (e.key === "Escape" && backdrop.classList.contains("show")) closeModal(); });

    function setModalTitle(name, cn){
      const safeName = escapeHtml(name || "Character");
      const safeCn = cn ? escapeHtml(cn) : "";
      modalTitle.innerHTML = safeCn ? `${safeName}<span class="cn">${safeCn}</span>` : safeName;
    }

    async function fetchAndOpen(cid) {
      openModal();
      modalBody.innerHTML = `<div class="modal-loading">Loading…</div>`;
      try {
        const r = await fetch(`/zones/zone-nova/characters/${encodeURIComponent(cid)}`, { cache: "no-store" });
        const j = await r.json();
        if (!j.ok) {
          modalBody.innerHTML = `<div class="detail-empty">불러오기 실패: ${escapeHtml(j.error || "unknown")}</div>`;
          return;
        }

        const detail = j.detail || {};
        const name = pick(detail, "name") || j.character?.name || j.id || "Character";
        const cn = pick(detail, "chineseName", "chinesename", "chinessname", "cnName", "cn_name");

        setModalTitle(name, cn);
        modalBody.innerHTML = renderDetailTabs(detail);
        bindTabEvents();
      } catch (e) {
        modalBody.innerHTML = `<div class="detail-empty">불러오기 실패: ${escapeHtml(String(e))}</div>`;
      }
    }

    // ===== List render =====
    function dedupeById(list){
      const m = new Map();
      for (const c of (list || [])){
        if (!c) continue;
        const id = (c.id || "").toString().trim();
        if (!id) continue;
        if (!m.has(id)) m.set(id, c);
      }
      return Array.from(m.values());
    }

    const chars = dedupeById(CHARS_RAW || []);

    const $tbody = document.getElementById("tbody");
    const $q = document.getElementById("q");
    const $rarity = document.getElementById("rarityFilter");
    const $elem = document.getElementById("elemFilter");
    const $faction = document.getElementById("factionFilter");
    const $class = document.getElementById("classFilter");
    const $role = document.getElementById("roleFilter");

    function uniqSorted(values){
      return Array.from(new Set(values.filter(v => v && v !== "-")))
        .sort((a,b) => a.localeCompare(b));
    }
    function fillSelect(sel, values){
      for (const v of values){
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v;
        sel.appendChild(opt);
      }
    }

    fillSelect($elem, uniqSorted(chars.map(c => (c.element || "-"))));
    fillSelect($faction, uniqSorted(chars.map(c => (c.faction || "-"))));
    fillSelect($class, uniqSorted(chars.map(c => classLabel(c.class))));
    fillSelect($role, uniqSorted(chars.map(c => roleLabel(c.role))));

    function matchFilters(c){
      const q = ($q.value || "").trim().toLowerCase();
      const rarityV = ($rarity.value || "").trim().toUpperCase();
      const elemV = ($elem.value || "").trim();
      const factionV = ($faction.value || "").trim();
      const classV = ($class.value || "").trim();
      const roleV = ($role.value || "").trim();

      const name = (c.name || "").toString().toLowerCase();
      const id = (c.id || "").toString().toLowerCase();
      const faction = (c.faction || "-").toString().toLowerCase();
      const elem = (c.element || "-").toString();

      if (q){
        const ok = name.includes(q) || id.includes(q) || faction.includes(q) || elem.toLowerCase().includes(q);
        if (!ok) return false;
      }
      if (rarityV && (c.rarity || "-").toString().toUpperCase() !== rarityV) return false;
      if (elemV && (c.element || "-") !== elemV) return false;
      if (factionV && (c.faction || "-") !== factionV) return false;
      if (classV && classLabel(c.class) !== classV) return false;
      if (roleV && roleLabel(c.role) !== roleV) return false;
      return true;
    }

    function sortChars(list){
      return list.slice().sort((a,b) => {
        const ra = rarityVal(a.rarity);
        const rb = rarityVal(b.rarity);
        if (rb !== ra) return rb - ra;
        const na = (a.name || a.id || "").toString();
        const nb = (b.name || b.id || "").toString();
        return na.localeCompare(nb);
      });
    }

    function render(){
      const filtered = sortChars(chars.filter(matchFilters));
      const rows = filtered.map(c => {
        const cid = c.id;
        const nm = c.name || cid;

        const elem = (c.element || "-");
        const faction = (c.faction || "-");
        const cls = classLabel(c.class);
        const role = roleLabel(c.role);
        const rar = (c.rarity || "-").toString().toUpperCase();

        const img = c.image
          ? `<img class="char-img" src="${escapeHtml(c.image)}" alt="">`
          : `<div class="char-img"></div>`;

        const elemIcon = c.element_icon ? `<img class="mini-icon" src="${escapeHtml(c.element_icon)}" alt="">` : "";
        const classIcon = c.class_icon ? `<img class="mini-icon" src="${escapeHtml(c.class_icon)}" alt="">` : "";

        return `
          <tr>
            <td class="col-check"><input class="chk-owned" type="checkbox" data-cid="${escapeHtml(cid)}"></td>
            <td>
              <div class="char-cell clickable" data-cid="${escapeHtml(cid)}">
                ${img}
                <div class="char-name">${escapeHtml(nm)}</div>
              </div>
            </td>
            <td class="col-elem">
              <span class="pill pill-neutral pill-with-icon">
                ${elemIcon}
                <span class="pill-text">${escapeHtml(elem)}</span>
              </span>
            </td>
            <td class="col-faction"><span class="pill pill-neutral">${escapeHtml(faction)}</span></td>
            <td class="col-class">
              <span class="pill pill-neutral pill-with-icon">
                ${classIcon}
                <span class="pill-text">${escapeHtml(cls)}</span>
              </span>
            </td>
            <td class="col-role"><span class="pill pill-neutral">${escapeHtml(role)}</span></td>
            <td class="col-rarity"><span class="pill ${rarityPillClass(rar)}">${escapeHtml(rar)}</span></td>
          </tr>
        `;
      }).join("");

      $tbody.innerHTML = rows || `<tr><td colspan="7" style="padding:18px;color:rgba(255,255,255,.70);font-weight:800;">표시할 캐릭터가 없습니다.</td></tr>`;
    }

    [$q, $rarity, $elem, $faction, $class, $role].forEach(el => {
      el.addEventListener("input", render);
      el.addEventListener("change", render);
    });

    document.getElementById("btnAll").addEventListener("click", () => {
      document.querySelectorAll(".chk-owned").forEach(x => x.checked = true);
    });
    document.getElementById("btnNone").addEventListener("click", () => {
      document.querySelectorAll(".chk-owned").forEach(x => x.checked = false);
    });

    document.addEventListener("click", (e) => {
      const chk = e.target.closest(".chk-owned");
      if (chk) return;
      const cell = e.target.closest(".char-cell.clickable");
      if (!cell) return;
      const cid = cell.dataset.cid;
      if (cid) fetchAndOpen(cid);
    });

    render();

    // ===== Filters collapse (mobile) =====
    // - 모바일에서는 기본 접힘
    // - 사용자가 한 번 열고/닫으면 localStorage로 기억
    (function initFiltersCollapse(){
      const d = document.getElementById("filtersPanel");
      if (!d) return;

      const KEY = "nova_filters_open";
      const mq = window.matchMedia("(max-width: 520px)");

      const applyDefault = () => {
        if (mq.matches) d.removeAttribute("open");
        else d.setAttribute("open", "");
      };

      const saved = localStorage.getItem(KEY);
      if (saved === "1") d.setAttribute("open", "");
      else if (saved === "0") d.removeAttribute("open");
      else applyDefault();

      d.addEventListener("toggle", () => {
        localStorage.setItem(KEY, d.open ? "1" : "0");
      });

      mq.addEventListener?.("change", () => {
        // 저장값이 없을 때만 자동 적용(사용자 선택을 덮어쓰지 않음)
        if (localStorage.getItem(KEY) == null) applyDefault();
      });
    })();

    // ===== Tier Party Builder =====
    let ALL_TIER_LISTS = null;
    const TIER_SCORE = { SSS: 4, SS: 3, S: 2, A: 1 };

    function keyify(s){
      return slugKey(s);
    }

    // key -> [id...] (동명이인/오버라이드 충돌 대비)
    function buildCharIndex(chars){
      const byKey = new Map();
      const byId = new Map((chars || []).map(c => [String(c.id), c]));

      function addKey(key, id){
        if (!key || !id) return;
        const arr = byKey.get(key) || [];
        if (!arr.includes(id)) arr.push(id);
        // SSR 우선 정렬(있어도 되고 없어도 되지만, 일관성 위해 유지)
        arr.sort((a,b) => rarityVal(byId.get(b)?.rarity) - rarityVal(byId.get(a)?.rarity));
        byKey.set(key, arr);
      }

      for (const c of (chars || [])){
        if (!c?.id) continue;
        const id = String(c.id);
        if (c.name) addKey(keyify(c.name), id);
        if (c.raw_name) addKey(keyify(c.raw_name), id);
        addKey(keyify(id), id);
      }
      return { byKey };
    }

    // ✅ 동일 name이 여러 id로 매핑되면 "전부" rankMap에 반영
    function buildRankMapFromTierList(tierList, chars){
      const { byKey } = buildCharIndex(chars);
      const rank = new Map();
      const tiers = tierList?.tiers || {};

      for (const [tier, arr] of Object.entries(tiers)){
        const T = String(tier).toUpperCase();
        if (!TIER_SCORE[T]) continue;

        const list = Array.isArray(arr) ? arr : [];
        for (const it of list){
          const nm = (it && typeof it === "object") ? it.name : null;
          const ids = byKey.get(keyify(nm));
          if (!ids || !ids.length) continue;

          for (const cid of ids){
            const prev = rank.get(cid) || 0;
            rank.set(cid, Math.max(prev, TIER_SCORE[T]));
          }
        }
      }
      return rank;
    }

    function getOwnedSelectedIds(){
      const out = [];
      document.querySelectorAll(".chk-owned").forEach(chk => {
        if (chk.checked && chk.dataset.cid) out.push(chk.dataset.cid);
      });
      return out;
    }

    function initTierClassCheckboxes(){
      const box = document.getElementById("tierClassBox");
      const use = document.getElementById("useClassFilter");
      if (!box || !use) return;

      const classes = Array.from(new Set((chars || []).map(c => String(c.class || "-")).filter(v => v && v !== "-")))
        .sort((a,b) => a.localeCompare(b));

      box.innerHTML = classes.map(cls => `
        <label class="tier-class-item">
          <input type="checkbox" value="${escapeHtml(cls)}" disabled>
          <span>${escapeHtml(cls)}</span>
        </label>
      `).join("");

      const toggle = () => {
        const on = !!use.checked;
        box.setAttribute("aria-disabled", String(!on));
        box.querySelectorAll("input[type=checkbox]").forEach(x => x.disabled = !on);
      };
      use.addEventListener("change", toggle);
      toggle();
    }

    function getEnabledClassSet(){
      const use = document.getElementById("useClassFilter")?.checked;
      if (!use) return null;

      const picked = new Set();
      document.querySelectorAll(".tier-class-item input[type=checkbox]").forEach(x => {
        if (x.checked) picked.add(x.value);
      });
      return picked.size ? picked : null;
    }

    function hasComboSkill(party, charsById){
      const elem = new Map();
      const fac = new Map();
      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) continue;
        const e = c.element || "-";
        const f = c.faction || "-";
        elem.set(e, (elem.get(e) || 0) + 1);
        fac.set(f, (fac.get(f) || 0) + 1);
      }
      const maxElem = Math.max(0, ...elem.values());
      const maxFac = Math.max(0, ...fac.values());
      return (maxElem >= 2) || (maxFac >= 2);
    }

    // ✅ 모든 파티원이 콤보(속성2+ 또는 특성2+)에 “참여”해야 함
    function allMembersContributeToCombo(party, charsById){
      const elemCount = new Map();
      const facCount = new Map();

      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) continue;
        const e = c.element || "-";
        const f = c.faction || "-";
        elemCount.set(e, (elemCount.get(e) || 0) + 1);
        facCount.set(f, (facCount.get(f) || 0) + 1);
      }

      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) return false;

        const e = c.element || "-";
        const f = c.faction || "-";

        const eOk = e !== "-" && (elemCount.get(e) || 0) >= 2;
        const fOk = f !== "-" && (facCount.get(f) || 0) >= 2;

        if (!eOk && !fOk) return false;
      }
      return true;
    }

    function isTank(c){
      const cls = String(c?.class || "").toLowerCase();
      const role = String(c?.role || "").toLowerCase();
      return cls === "guardian" || role === "tank";
    }

    function isHealer(c){
      const cls = String(c?.class || "").toLowerCase();
      const role = String(c?.role || "").toLowerCase();
      return cls === "healer" || role === "healer";
    }

    function passesTankHealerCap(party, charsById){
      let tank = 0, healer = 0;
      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) continue;
        if (isTank(c)) tank++;
        if (isHealer(c)) healer++;
        if (tank > 1 || healer > 1) return false;
      }
      return true;
    }

    function passesRequiredClasses(party, charsById, requiredClassSet){
      if (!requiredClassSet || requiredClassSet.size === 0) return true;

      const seen = new Set();
      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) continue;
        seen.add(String(c.class || "-"));
      }

      for (const req of requiredClassSet){
        if (!seen.has(req)) return false;
      }
      return true;
    }

    function partyScore(party, rankMap, charsById){
      let sum = 0;
      const elem = new Map();
      const fac = new Map();

      for (const cid of party){
        const c = charsById.get(cid);

        // tier 점수
        sum += (rankMap.get(cid) || 0) * 100;

        // rarity 보너스(동명이인 충돌 상황에서 SSR 우선 선택 유도)
        sum += rarityVal(c?.rarity) * 5;

        if (!c) continue;
        const e = c.element || "-";
        const f = c.faction || "-";
        elem.set(e, (elem.get(e) || 0) + 1);
        fac.set(f, (fac.get(f) || 0) + 1);
      }

      const maxElem = Math.max(0, ...elem.values());
      const maxFac = Math.max(0, ...fac.values());

      if (maxElem >= 2) sum += 20;
      if (maxFac >= 2) sum += 20;
      if (maxElem >= 3) sum += 10;
      if (maxFac >= 3) sum += 10;

      return sum;
    }

    function tierLabelFromScore(s){
      if (s === 4) return "SSS";
      if (s === 3) return "SS";
      if (s === 2) return "S";
      if (s === 1) return "A";
      return "-";
    }

    /**
     * ✅ 한 번에 "최고 1개 파티"를 뽑는다(현재 남아있는 후보 중)
     * - usedSet(카테고리 내부 중복 금지)을 반영해 후보에서 제외
     * - 조건 만족하는 4인 조합 중 점수 최고 선택
     */
    function buildBestPartyOnce(rankMap, usedSet){
      const owned = getOwnedSelectedIds();
      if (owned.length < 4) return { ok:false, msg:"보유 체크가 4명 이상이어야 합니다." };

      const charsById = new Map(chars.map(c => [c.id, c]));

      // usedSet에 포함된 캐릭터는 제외(= 같은 카테고리 안에서 중복 금지)
      const candidatesAll = owned
        .filter(cid => charsById.has(cid))
        .filter(cid => !usedSet.has(cid));

      if (candidatesAll.length < 4){
        return { ok:false, msg:"(중복 제외 후) 후보가 부족하여 파티를 구성할 수 없습니다." };
      }

      const classSet = getEnabledClassSet();
      if (classSet && classSet.size > 4){
        return { ok:false, msg:"선택 클래스는 최대 4개까지만 지정할 수 있습니다(4인 파티)." };
      }

      // tier 우선 정렬(없으면 0)
      const candidates = candidatesAll.slice().sort((a,b) => (rankMap.get(b) || 0) - (rankMap.get(a) || 0));

      // 탐색 풀 제한(브라우저 성능 보호)
      const N = Math.min(28, candidates.length);
      const pool = candidates.slice(0, N);

      let best = null;
      for (let i=0; i<pool.length-3; i++){
        for (let j=i+1; j<pool.length-2; j++){
          for (let k=j+1; k<pool.length-1; k++){
            for (let l=k+1; l<pool.length; l++){
              const party = [pool[i], pool[j], pool[k], pool[l]];

              if (!passesTankHealerCap(party, charsById)) continue;
              if (!passesRequiredClasses(party, charsById, classSet)) continue;

              if (!hasComboSkill(party, charsById)) continue;
              if (!allMembersContributeToCombo(party, charsById)) continue;

              const sc = partyScore(party, rankMap, charsById);
              if (!best || sc > best.score) best = { party, score: sc };
            }
          }
        }
      }

      if (!best) return { ok:false, msg:"조건을 만족하는 4인 조합을 찾지 못했습니다." };
      return { ok:true, party: best.party };
    }

    /**
     * ✅ 카테고리별로 n개 파티 만들기(카테고리 내부 중복 금지)
     */
    function buildPartiesForCategory(rankMap, n){
      const used = new Set();
      const parties = [];

      for (let i=0; i<n; i++){
        const res = buildBestPartyOnce(rankMap, used);
        if (!res.ok) break;

        parties.push(res.party);
        // 같은 카테고리 내 중복 금지: 선택된 4명은 used에 추가
        for (const cid of res.party) used.add(cid);
      }

      return parties;
    }

    /**
     * ✅ 최종 요구사항:
     * - Guild 3 (중복 없이)
     * - PVE 1
     * - PVP 2 (중복 없이)
     * - Rift 2 (중복 없이)
     */
    function buildAllCategoryParties(rankMap){
      return {
        Guild: buildPartiesForCategory(rankMap, 3),
        PVE:   buildPartiesForCategory(rankMap, 1),
        PVP:   buildPartiesForCategory(rankMap, 2),
        Rift:  buildPartiesForCategory(rankMap, 2),
      };
    }

    // ✅ 선택한 등급표(pve/pvp/rift/guild-raid/...)에 맞춰 결과 카테고리를 제한
    function buildPartiesByPresetKey(rankMap, presetKey){
      const k = String(presetKey || "").toLowerCase();

      // 기본값: 기존과 동일(전체 카테고리)
      const def = { order: ["Guild", "PVE", "PVP", "Rift"], data: buildAllCategoryParties(rankMap) };

      if (k === "pvp") {
        return { order: ["PVP"], data: { PVP: buildPartiesForCategory(rankMap, 2) } };
      }
      if (k === "pve" || k === "new-player") {
        return { order: ["PVE"], data: { PVE: buildPartiesForCategory(rankMap, 1) } };
      }
      if (k === "rift") {
        return { order: ["Rift"], data: { Rift: buildPartiesForCategory(rankMap, 2) } };
      }
      if (k === "guild-raid") {
        return { order: ["Guild"], data: { Guild: buildPartiesForCategory(rankMap, 3) } };
      }
      return def;
    }

    function renderTierPartyResult(rankMap, res){
      const box = document.getElementById("tierPartyResult");
      if (!box) return;

      if (!res.ok){
        box.innerHTML = `<div class="tier-error">${escapeHtml(res.msg || "실패")}</div>`;
        return;
      }

      const charsById = new Map(chars.map(c => [c.id, c]));

      const renderOneParty = (party) => {
        const cards = party.map(cid => {
          const c = charsById.get(cid);

          const img = c?.image
            ? `<img class="tier-portrait" src="${escapeHtml(c.image)}" alt="">`
            : `<div class="tier-portrait tier-portrait-empty"></div>`;

          return `
            <div class="tier-card">
              <div class="tier-card-top">
                ${img}
                <span class="tier-name">${escapeHtml(c?.name || cid)}</span>
              </div>
              <div class="tier-card-sub">
                <span class="pill pill-neutral">${escapeHtml(c?.element || "-")}</span>
                <span class="pill pill-neutral">${escapeHtml(c?.faction || "-")}</span>
                <span class="pill pill-neutral">${escapeHtml(c?.class || "-")}</span>
              </div>
            </div>
          `;
        }).join("");

        return `<div class="tier-grid">${cards}</div>`;
      };

      const sections = res.data;
      const order = Array.isArray(res.order) && res.order.length
        ? res.order
        : ["Guild", "PVE", "PVP", "Rift"];

      const html = order.map(cat => {
        const parties = sections[cat] || [];
        if (!parties.length){
          return `
            <div class="tier-section">
              <div class="tier-section-head">
                <div class="tier-section-title">${escapeHtml(cat)}</div>
              </div>
              <div class="tier-error" style="margin-top:8px;">${escapeHtml(cat)}: 조건을 만족하는 파티를 구성하지 못했습니다(후보 부족/조건 과다).</div>
            </div>
          `;
        }

        return `
          <div class="tier-section">
            <div class="tier-section-head">
              <div class="tier-section-title">${escapeHtml(cat)}</div>
              <div class="tier-section-sub">총 ${parties.length}개</div>
            </div>
            ${parties.map((p, idx) => `
              <div class="tier-party-block">
                <div class="tier-party-title">${escapeHtml(cat)} ${idx + 1}</div>
                ${renderOneParty(p)}
              </div>
            `).join("")}
          </div>
        `;
      }).join("");

      box.innerHTML = html;
    }

    function initTierUI(){
      const sel = document.getElementById("tierPreset");
      const btn = document.getElementById("btnBuildTierParty");
      // ✅ 요청사항: 구성조건/lastUpdated 안내 영역 제거(없어도 동작)
      const info = document.getElementById("tierInfo"); // (없을 수 있음)
      const help = document.getElementById("tierHelp"); // (없을 수 있음)
      if (!sel || !btn) return;
      if (!ALL_TIER_LISTS) return;

      const keys = Object.keys(ALL_TIER_LISTS).sort((a,b) => a.localeCompare(b));

      sel.innerHTML = `<option value="">등급표 선택</option>` + keys.map(k => {
        const t = ALL_TIER_LISTS[k];
        const nm = String(t?.name || k).trim();
        return `<option value="${escapeHtml(k)}">${escapeHtml(nm)}</option>`;
      }).join("");

      sel.disabled = false;
      btn.disabled = false;

      initTierClassCheckboxes();

      function renderInfo(k){
        // ✅ 요청사항: 구성조건/lastUpdated 등의 안내 문구는 표시하지 않음
        if (info) info.textContent = "";
        if (help) help.innerHTML = "";
      }

      sel.addEventListener("change", () => {
        renderInfo(sel.value);
        document.getElementById("tierPartyResult").innerHTML = "";
      });

      btn.addEventListener("click", () => {
        const k = sel.value;
        if (!k) {
          renderTierPartyResult(new Map(), { ok:false, msg:"등급표를 먼저 선택하세요." });
          return;
        }
        const tierList = ALL_TIER_LISTS[k];
        const rankMap = buildRankMapFromTierList(tierList, chars);

        const built = buildPartiesByPresetKey(rankMap, k);
        renderTierPartyResult(rankMap, { ok:true, ...built });
      });

      renderInfo(sel.value);
    }

    // ===== Tier (details) collapse: 검색/필터와 동일한 (열기/닫기) UX =====
    // - 모바일에서는 기본 접힘
    // - 사용자가 한 번 열고/닫으면 localStorage로 기억
    (function initTierDetailsCollapse(){
      const d = document.getElementById("tierPanel");
      if (!d) return;

      const KEY = "tierPanelOpen";
      const mq = window.matchMedia("(max-width: 520px)");

      const applyDefault = () => {
        if (mq.matches) d.removeAttribute("open");
        else d.setAttribute("open", "");
      };

      const saved = localStorage.getItem(KEY);
      if (saved === "1") d.setAttribute("open", "");
      else if (saved === "0") d.removeAttribute("open");
      else applyDefault();

      d.addEventListener("toggle", () => {
        localStorage.setItem(KEY, d.open ? "1" : "0");
      });

      mq.addEventListener?.("change", () => {
        if (localStorage.getItem(KEY) == null) applyDefault();
      });
    })();

    window.addEventListener("tierlists:loaded", () => {
      ALL_TIER_LISTS = window.__tierLists?.ALL_TIER_LISTS || null;

      if (!ALL_TIER_LISTS) {
        const sel = document.getElementById("tierPreset");
        const info = document.getElementById("tierInfo");
        if (sel) {
          sel.innerHTML = `<option value="">등급표 로딩 실패</option>`;
          sel.disabled = true;
        }
        if (info) {
          info.textContent = "tier-lists.js(tier-list.js) 모듈을 불러오지 못했습니다. 경로/파일명을 확인하세요.";
        }
        return;
      }

      initTierUI();
    });
  </script>

  <!-- ✅ tier-lists 모듈 import (파일명 혼동 대비 fallback) -->
  <script type="module">
    const candidates = [
      "/data/zone-nova/tier-lists.js",
      "/data/zone-nova/tier-list.js"
    ];

    let mod = null;
    for (const p of candidates) {
      try {
        mod = await import(p);
        window.__tierLists = mod;
        window.__tierListsPath = p;
        break;
      } catch (e) {}
    }

    window.dispatchEvent(new Event("tierlists:loaded"));
  </script>

</body>
</html>
