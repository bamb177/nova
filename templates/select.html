<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>{{ title }}</title>

  <!-- 공통/페이지 CSS 분리 유지 -->
  <link rel="stylesheet" href="/css/select.css?v={{ last_refresh }}" />

  <!-- ✅ Tier 결과 카드 이미지 + PC 폭 확장 오버라이드 -->
</head>

<body>
  
  <div id="jsErrorBanner" style="display:none;position:sticky;top:0;z-index:9999;background:rgba(180,40,40,.92);color:#fff;padding:10px 14px;font-weight:700;border-bottom:1px solid rgba(255,255,255,.25);">
    JS 오류: <span id="jsErrorText"></span>
  </div>
<div class="wrap">

    <!-- ===== Topbar ===== -->
    <div class="topbar">
      <div class="title-row">
        <h1>{{ title }}</h1>
        <a class="navbtn" href="/runes">룬 정보</a>
        <div class="meta-inline">캐릭터 {{ cache_count }}명</div>
        <div class="refresh">갱신 {{ last_refresh }}</div>
      </div>
    </div>
    
  
    {% if error %}
      <div class="error">로딩 오류: {{ error }}</div>
    {% endif %}

    <div class="panel">

      <!-- ===== Filters (Mobile collapsible) ===== -->
      <details id="filtersPanel" class="filters-box" open>
        <summary class="filters-summary">
          <span class="filters-summary-title">검색/필터</span>
          <span class="filters-summary-hint">(열기/닫기)</span>
        </summary>

        <div class="filters-body">
          <div class="filters">
            <input id="q" class="input" type="text" placeholder="검색 (이름/ID/특성/속성)" autocomplete="off" />

            <select id="classFilter" class="select">
              <option value="">클래스(전체)</option>
            </select>

            <select id="rarityFilter" class="select">
              <option value="">등급(전체)</option>
              <option value="SSR">SSR</option>
              <option value="SR">SR</option>
            </select>

            <select id="elemFilter" class="select">
              <option value="">속성(전체)</option>
            </select>

            <select id="factionFilter" class="select">
              <option value="">특성(전체)</option>
            </select>

            <select id="roleFilter" class="select">
              <option value="">역할(전체)</option>
            </select>
</div>
        </div>
      </details>

      <!-- ===== Tier Party Builder (details: open/close like filters) ===== -->
      <details class="tier-panel" id="tierPanel" open>
        <summary class="tier-summary">
          <span class="tier-summary-title">등급표</span>
          <span class="tier-summary-hint">(열기/닫기)</span>
        </summary>

        <div class="tier-body">
          <!-- 1줄: 등급표선택 / 등급표로파티구성 / AI추천파티 / 파티초기화 -->
          <div class="tier-row tier-topline">
            <select id="tierPreset" class="select" disabled>
              <option value="">tier-lists.js 로딩중...</option>
            </select>

            <div class="tier-btnrow">
              <button class="btn" id="btnBuildTierParty" type="button" disabled>등급표 파티</button>
              <button class="btn" id="btnAiParty" type="button" disabled>AI 추천 파티</button>
              <button class="btn" id="btnResetParties" type="button">파티 초기화</button>
            </div>
          </div>

          <!-- 2줄: 선택클래스포함조건 / 전체선택 / 전체해제 -->
          <div class="tier-row tier-secondline">
            <details class="subpanel" id="classCondPanel" open>
              <summary class="subpanel-summary">
                <span class="subpanel-title">선택 클래스 포함 조건</span>
                <span class="subpanel-toggle">(열기/닫기)</span>
              </summary>

              <div class="tier-class-inline" id="tierClassInline">
                <label class="tier-check tier-check-inline" title="체크한 클래스가 파티(4인)에 포함되도록 구성합니다. 후보를 해당 클래스로만 제한하지 않습니다.">
                  <input type="checkbox" id="useClassFilter" />
                  포함 조건 사용
                </label>
                <div class="tier-classes tier-classes-inline" id="tierClassBox" aria-disabled="true"></div>
              </div>
            </details>
            <div class="tier-actions-row">
              <button class="btn" id="btnAll" type="button">전체 선택</button>
              <button class="btn" id="btnNone" type="button">전체 해제</button>
            </div>
          </div>

          <div id="tierPartyResult" class="tier-result"></div>
          <div id="aiPartyResult" class="tier-result"></div>
        </div>
      </details>

<!-- ===== Characters list ===== -->
      <div class="table-wrap">
        <table class="table">
          <thead>
            <tr>
              <th class="col-check">선택</th>
                            <th class="col-char">캐릭터</th>
              <th class="col-hp th-sort" data-sort="hp">체력</th>
              <th class="col-def th-sort" data-sort="defense">방어력</th>
              <th class="col-atk th-sort" data-sort="attack">공격력</th>
              <th class="col-crit th-sort" data-sort="critRate">크리%</th>
              <th class="col-elem">속성</th>
              <th class="col-faction">특성</th>
              <th class="col-class">클래스</th>
              <th class="col-role">역할</th>
              <th class="col-rarity">등급</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>

    </div><!-- /.panel -->
  </div><!-- /.wrap -->

  <!-- ===== Modal ===== -->
  <div class="modal-backdrop" id="modalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modal-head">
        <div class="modal-title" id="modalTitle">Character</div>
        <button class="modal-close" id="modalClose" type="button">×</button>
      </div>
      <div class="modal-body" id="modalBody">
        <div class="modal-loading">Loading…</div>
      </div>
    </div>
  </div>

  <script>
    const CHARS_RAW = {{ chars_json|safe }};

    function escapeHtml(str) {
      return (str || "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }

    

    function formatDescText(s){
      const t = String(s ?? "");
      // Korean sentence breaks: force newline after "다." when followed by whitespace
      // Also keep basic breaks after . ? !
      return t
        .replace(/다\.(\s+)/g, "다.<br>")
        .replace(/([\.\?\!])\s+/g, "$1<br>");
    }
function pick(obj, ...keys) {
      for (const k of keys) {
        const v = obj?.[k];
        if (v !== undefined && v !== null) return v;
      }
      return null;
    }

    function isEmpty(v) {
      if (v === null || v === undefined) return true;
      if (Array.isArray(v)) return v.length === 0;
      if (typeof v === "object") return Object.keys(v).length === 0;
      if (typeof v === "string") return v.trim() === "";
      return false;
    }

    function slugKey(s){
      return String(s || "")
        .toLowerCase()
        .replace(/[’']/g, "")
        .replace(/[\s\-_]+/g, "")
        .trim();
    }

    // -------------------------
    // Rune set meta (for set effects in 추천 룬)
    // - setPlan 항목에 효과 텍스트가 없을 때, 정적 runes.js(또는 json)에서 보강
    // -------------------------
    var RUNE_SET_META = null; // { [slugKey(setName)]: { name, effect2p, effect4p, effectAny } }

    function normalizeRuneSetMeta(src){
      // src can be:
      // - ES module exports (runes.js)
      // - plain JSON object/array
      if (!src) return null;

      // 1) pick likely containers
      const cands = [
        src.RUNE_SETS, src.RUNESETS, src.RUNE_SET, src.RUNESET,
        src.RUNES, src.runes, src.sets, src.SETS,
        src.default, src.data
      ];

      let base = null;
      for (const c of cands){
        if (!c) continue;
        if (Array.isArray(c)) { base = c; break; }
        if (typeof c === "object" && !Array.isArray(c)){
          if (Array.isArray(c.sets)) { base = c.sets; break; }
          if (Array.isArray(c.items)) { base = c.items; break; }
          if (Array.isArray(c.runes)) { base = c.runes; break; }
          // sometimes it is already a map keyed by set name
          if (Object.keys(c).length && Object.values(c).some(v => typeof v === "object")) { base = c; break; }
        }
      }
      if (!base && Array.isArray(src)) base = src;
      if (!base) return null;

      const out = {};

      function normalizeOne(name, it){
        const setName = String(name || "").trim();
        if (!setName) return;

        const key = slugKey(setName);

        // direct fields
        let e2 = pick(it, "effect2p","effect_2p","effect2","twoPiece","two_piece","twoEffect","set2","set2Effect","two");
        let e4 = pick(it, "effect4p","effect_4p","effect4","fourPiece","four_piece","fourEffect","set4","set4Effect","four");

        // nested effects containers
        const fx = pick(it, "effects","effect","setEffects","set_effects");
        if (fx){
          if (Array.isArray(fx)){
            // common: [2p, 4p]
            if (!e2 && fx[0] != null) e2 = (typeof fx[0] === "string") ? fx[0] : pick(fx[0],"text","desc","description","effect");
            if (!e4 && fx[1] != null) e4 = (typeof fx[1] === "string") ? fx[1] : pick(fx[1],"text","desc","description","effect");
          } else if (typeof fx === "object"){
            const k2 = pick(fx, "2","2p","two","twoPiece","two_piece");
            const k4 = pick(fx, "4","4p","four","fourPiece","four_piece");
            if (!e2 && typeof k2 === "string") e2 = k2;
            if (!e4 && typeof k4 === "string") e4 = k4;
          } else if (typeof fx === "string"){
            // sometimes one description only
          }
        }

        const any = pick(it, "effect","desc","description","text");

        out[key] = {
          name: setName,
          effect2p: (typeof e2 === "string") ? e2 : "",
          effect4p: (typeof e4 === "string") ? e4 : "",
          effectAny: (typeof any === "string") ? any : "",
        };
      }

      if (Array.isArray(base)){
        for (const it of base){
          if (!it) continue;
          const nm = pick(it, "set","name","title");
          normalizeOne(nm, it);
        }
        return Object.keys(out).length ? out : null;
      }

      // object map form
      if (typeof base === "object"){
        for (const [k, v] of Object.entries(base)){
          if (!v) continue;
          // key might be the name itself
          const nm = pick(v, "set","name","title") || k;
          normalizeOne(nm, v);
        }
        return Object.keys(out).length ? out : null;
      }

      return null;
    }

    function setRuneSetMeta(meta){
      RUNE_SET_META = (meta && typeof meta === "object") ? meta : null;
      try{
        window.__runeSetMeta = RUNE_SET_META;
        window.dispatchEvent(new Event("runesmeta:loaded"));
      }catch(e){}
    }

    // expose for module loader
    try{
      window.normalizeRuneSetMeta = normalizeRuneSetMeta;
      window.setRuneSetMeta = setRuneSetMeta;
    }catch(e){}

    function extractEffectFromPlanItem(item, pieces){
      if (!item || typeof item !== "object") return "";
      const p = Number(pieces || 0) || 0;

      if (p >= 4){
        const e4 = pick(item, "effect4p","effect_4p","fourEffect","fourPiece","four_piece","effect4","set4Effect");
        if (typeof e4 === "string" && e4.trim()) return e4;
      }
      if (p === 2){
        const e2 = pick(item, "effect2p","effect_2p","twoEffect","twoPiece","two_piece","effect2","set2Effect");
        if (typeof e2 === "string" && e2.trim()) return e2;
      }
      const any = pick(item, "effect","desc","description","text","effectText","effect_text");
      return (typeof any === "string") ? any : "";
    }

    function lookupEffectFromMeta(setName, pieces){
      if (!RUNE_SET_META) return "";
      const key = slugKey(setName);
      const m = RUNE_SET_META[key];
      if (!m) return "";
      const p = Number(pieces || 0) || 0;

      if (p >= 4 && m.effect4p) return m.effect4p;
      if (p === 2 && m.effect2p) return m.effect2p;
      return m.effectAny || "";
    }

    function getRuneSetEffectText(setName, pieces, planItem){
      const fromItem = extractEffectFromPlanItem(planItem, pieces);
      if (fromItem && String(fromItem).trim()) return String(fromItem).trim();

      const fromMeta = lookupEffectFromMeta(setName, pieces);
      if (fromMeta && String(fromMeta).trim()) return String(fromMeta).trim();

      return "";
    }

    function hydrateRuneSetEffects(root){
      const scope = root || document;
      if (!scope || !RUNE_SET_META) return;

      try{
        scope.querySelectorAll(".rune-set[data-setkey]").forEach(setEl => {
          const effEl = setEl.querySelector(".rune-set-eff");
          if (!effEl) return;
          if (effEl.dataset && effEl.dataset.hasEffect === "1") return;

          const setKey = setEl.getAttribute("data-setkey") || "";
          const pieces = Number(setEl.getAttribute("data-pieces") || effEl.getAttribute("data-effect-pieces") || 0) || 0;

          const m = RUNE_SET_META[setKey];
          if (!m) return;

          const txt = (pieces >= 4 ? m.effect4p : (pieces === 2 ? m.effect2p : "")) || m.effectAny || "";
          if (!txt) return;

          effEl.innerHTML = formatDescText(escapeHtml(String(txt)));
          if (effEl.dataset) effEl.dataset.hasEffect = "1";
        });
      }catch(e){}
    }

    window.addEventListener("runesmeta:loaded", () => {
      try { hydrateRuneSetEffects(document.getElementById("modalBody")); } catch(e){}
    });


    // -------------------------
    // 필수(파티 지정) 상태 관리 (초기화는 render보다 먼저)
    // -------------------------
    // MUST_STATE[cid] = { on: true/false, target: "" | "Guild:1" | "PVP:2" | "Left:1", role: "" | "Tank" | "DPS" | "Healer" | "Buffer" | "Debuffer" }
    var MUST_STATE = {};
    const MUST_KEY = "nova.must.v1";

    function loadMustState(){
      try{
        const raw = localStorage.getItem(MUST_KEY);
        const obj = raw ? JSON.parse(raw) : {};
        return (obj && typeof obj === "object") ? obj : {};
      }catch(e){
        return {};
      }
    }

    function saveMustState(){
      try{ localStorage.setItem(MUST_KEY, JSON.stringify(MUST_STATE || {})); }catch(e){}
    }

    MUST_STATE = loadMustState();

    const RARITY_ORDER = { "SSR": 3, "SR": 2, "R": 1, "-": 0 };
    function rarityVal(r){
      const x = String(r || "-").toUpperCase();
      return RARITY_ORDER[x] ?? 0;
    }

    function classLabel(cls){
      const v = (cls || "-").toString().trim();
      return v || "-";
    }
    function roleLabel(role){
      const v = (role || "-").toString().trim();
      return v || "-";
    }
    function rarityPillClass(r){
      const v = (r || "-").toString().trim().toUpperCase();
      if (v === "SSR") return "pill-ssr";
      if (v === "SR") return "pill-sr";
      if (v === "R") return "pill-r";
      return "pill-none";
    }

    // ===== Modal rendering (skills/awakenings/memory) =====
    function renderKV(obj) {
      if (!obj || typeof obj !== "object") return `<div class="detail-empty">데이터 없음</div>`;
      const rows = Object.entries(obj).map(([k, v]) => {
        const vv = (typeof v === "object") ? JSON.stringify(v) : String(v);
        return `<tr><td class="kv-k">${escapeHtml(k)}</td><td class="kv-v">${escapeHtml(vv)}</td></tr>`;
      }).join("");
      return `<table class="kv"><tbody>${rows}</tbody></table>`;
    }

    function looksLikeSkillObject(o){
      if (!o || typeof o !== "object" || Array.isArray(o)) return false;
      const keys = ["name","title","skillName","description","desc","text","cooldown","energyCost","cost","type","category"];
      return keys.some(k => o[k] !== undefined && o[k] !== null);
    }

    function normalizeSkillEntry(x, fallbackTitle) {
      if (!x) return { title: fallbackTitle || "-", desc: "", extra: null };

      if (typeof x === "string") {
        return { title: fallbackTitle || "-", desc: x, extra: null };
      }

      if (typeof x === "object") {
        const title =
          (typeof x.name === "string" && x.name) ||
          (typeof x.title === "string" && x.title) ||
          (typeof x.skillName === "string" && x.skillName) ||
          fallbackTitle || "-";

        const desc =
          (typeof x.description === "string" && x.description) ||
          (typeof x.desc === "string" && x.desc) ||
          (typeof x.text === "string" && x.text) ||
          "";

        const extra = {};
        for (const [k, v] of Object.entries(x)) {
          if (["name","title","skillName","description","desc","text"].includes(k)) continue;
          if (v === null || v === undefined) continue;
          if (typeof v === "object") continue;
          extra[k] = v;
        }
        return { title, desc, extra: Object.keys(extra).length ? extra : null };
      }

      return { title: fallbackTitle || "-", desc: String(x), extra: null };
    }

    function renderOneSkillCard(s) {
      const desc = s.desc
        ? `<div class="card-desc">${formatDescText(escapeHtml(s.desc))}</div>`
        : `<div class="card-desc" style="opacity:.75;">(설명 없음)</div>`;
      const extra = s.extra ? renderKV(s.extra) : "";
      return `
        <div class="card">
          <div class="card-title"><span>${escapeHtml(String(s.title || "-"))}</span></div>
          ${desc}
          ${extra ? `<div style="margin-top:8px;">${extra}</div>` : ""}
        </div>
      `;
    }

    function renderSkillCards(skillsObjOrArr) {
      if (isEmpty(skillsObjOrArr)) return `<div class="detail-empty">스킬 데이터 없음</div>`;

      if (looksLikeSkillObject(skillsObjOrArr)) {
        const s = normalizeSkillEntry(skillsObjOrArr, "Skill");
        return `<div class="cards">${renderOneSkillCard(s)}</div>`;
      }

      if (Array.isArray(skillsObjOrArr)) {
        const cards = skillsObjOrArr
          .map((x, idx) => renderOneSkillCard(normalizeSkillEntry(x, `Skill ${idx + 1}`)))
          .join("");
        return `<div class="cards">${cards}</div>`;
      }

      if (typeof skillsObjOrArr === "object") {
        const cards = [];
        for (const [k, v] of Object.entries(skillsObjOrArr)) {
          if (isEmpty(v)) continue;

          if (looksLikeSkillObject(v)) {
            cards.push(renderOneSkillCard(normalizeSkillEntry(v, k)));
            continue;
          }

          if (Array.isArray(v)) {
            for (let i = 0; i < v.length; i++) {
              cards.push(renderOneSkillCard(normalizeSkillEntry(v[i], `${k} ${i + 1}`)));
            }
          }
        }

        if (cards.length === 0) {
          const s = normalizeSkillEntry(skillsObjOrArr, "Skill");
          return `<div class="cards">${renderOneSkillCard(s)}</div>`;
        }
        return `<div class="cards">${cards.join("")}</div>`;
      }

      const s = normalizeSkillEntry(skillsObjOrArr, "Skill");
      return `<div class="cards">${renderOneSkillCard(s)}</div>`;
    }

    function renderSkills(detail) {
      const skills = pick(detail, "skills") || {};
      const teamSkill = pick(detail, "teamSkill", "team_skill", "team");
      const normalData = !isEmpty(skills?.normal) ? skills.normal : skills?.basic;

      const sections = [
        { label: "Auto",       data: skills?.auto,     css: "group-auto" },
        { label: "Ultimate",   data: skills?.ultimate, css: "group-ultimate" },
        { label: "Passive",    data: skills?.passive,  css: "group-passive" },
        { label: "Normal",     data: normalData,       css: "group-normal" },
        { label: "Team Skill", data: teamSkill,        css: "group-team" },
      ];

      return sections.map(s => `
        <div class="group ${s.css}">
          <div class="group-title">${escapeHtml(s.label)}</div>
          ${isEmpty(s.data) ? `<div class="detail-empty">${escapeHtml(s.label)} 데이터 없음</div>` : renderSkillCards(s.data)}
        </div>
      `).join("");
    }

    function normalizeAwakenings(aw) {
      if (!aw) return [];
      if (Array.isArray(aw)) return aw;
      if (typeof aw === "object" && Array.isArray(aw.levels)) return aw.levels;
      return [];
    }

    function awakenRowEffect(x) {
      if (x == null) return "";
      if (typeof x === "string") return x;
      if (typeof x === "number" || typeof x === "boolean") return String(x);
      if (typeof x === "object") {
        const eff = pick(x, "effect", "effects", "desc", "description", "text");
        if (typeof eff === "string") return eff;
        return JSON.stringify(x, null, 2);
      }
      return String(x);
    }

    function renderAwakenings(detail) {
      const aw = pick(detail, "awakenings", "awakening");
      const rows = normalizeAwakenings(aw);
      if (!rows.length) return `<div class="detail-empty">각성 데이터 없음</div>`;

      const tbody = rows.map((x, idx) => {
        const lvl = pick(x, "level", "lv", "stage") ?? (idx + 1);
        const eff = awakenRowEffect(x);
        return `<tr><td style="width:110px;font-weight:950;">Lv.${escapeHtml(String(lvl))}</td><td>${escapeHtml(eff)}</td></tr>`;
      }).join("");

      return `
        <table class="awak-table">
          <thead><tr><th style="width:110px;">레벨</th><th>효과</th></tr></thead>
          <tbody>${tbody}</tbody>
        </table>
      `;
    }

    function renderMemoryCard(detail) {
      const mem = pick(detail, "memoryCard", "memory_card");
      if (isEmpty(mem)) return `<div class="detail-empty">메모리카드 데이터 없음</div>`;
      if (typeof mem !== "object") return `<div class="detail-empty">${escapeHtml(String(mem))}</div>`;

      const name = pick(mem, "name", "title") || "Memory Card";
      const desc = pick(mem, "description", "desc", "text") || "";
      const effects = pick(mem, "effects", "effect");

      let effectsHtml = "";
      if (Array.isArray(effects)) {
        const charName = pick(detail, "name") || "";
        const imgUrl = `/images/games/zone-nova/card/${encodeURIComponent(String(charName))}card.jpg`;

        const effRows = (effects || []).map(e => {
          if (typeof e === "string") return e;
          try { return JSON.stringify(e, null, 2); } catch { return String(e); }
        });

        if (effRows.length === 0) {
          effectsHtml = `<div class="detail-empty">효과 데이터 없음</div>`;
        } else {
          const first = effRows[0];
          const rest = effRows.slice(1);

          const tbody = [
            `<tr>
               <td class="memcard-imgcell" rowspan="${effRows.length}">
                 <img class="memcard-img" src="${imgUrl}" alt="Memory Card"
                      onerror="this.classList.add('hidden');" />
               </td>
               <td>${escapeHtml(first)}</td>
             </tr>`,
            ...rest.map(x => `<tr><td>${escapeHtml(x)}</td></tr>`)
          ].join("");

          effectsHtml = `
            <table class="awak-table memcard-table">
              <thead><tr><th class="memcard-th">카드</th><th>효과</th></tr></thead>
              <tbody>${tbody}</tbody>
            </table>
          `;
        }
      } else if (effects && typeof effects === "object") {
        effectsHtml = renderKV(effects);
      } else if (typeof effects === "string") {
        effectsHtml = `<div class="card-desc">${escapeHtml(effects)}</div>`;
      } else {
        effectsHtml = renderKV(mem);
      }

      return `
        <div class="card">
          <div class="card-title"><span>${escapeHtml(String(name))}</span></div>
          ${desc ? `<div class="card-desc">${formatDescText(escapeHtml(String(desc)))}</div>` : ""}
          <div style="margin-top:10px;">${effectsHtml}</div>
        </div>
      `;
    }

    function renderPanel(id, html, active=false) {
      return `<div class="tab-panel ${active ? "active" : ""}" data-panel="${escapeHtml(id)}">${html}</div>`;
    }

    
    function renderRecommendedRunes(runeReco) {
      // Backward compatibility:
      // - old: {mode, builds:[...]}
      // - new: {mode:"both", pve:{...}, pvp:{...}}
      const isBoth = runeReco && runeReco.mode === "both" && runeReco.pve && runeReco.pvp;

      function pickBuilds(obj){
        if (!obj || !Array.isArray(obj.builds) || obj.builds.length === 0) return null;
        return obj.builds;
      }

      
      function renderSetItem(s) {
        const icon = (s && s.icon)
          ? `<img class="rune-ico" src="${escapeHtml(String(s.icon))}" alt="" loading="lazy"
               onerror="this.onerror=null;this.src='data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';this.classList.add('rune-ico-broken');" />`
          : `<div class="rune-ico rune-ico-empty"></div>`;

        const setNameRaw = String(s && s.set ? s.set : "-");
        const name = escapeHtml(setNameRaw);
        const pcsNum = Number(s && s.pieces ? s.pieces : 0) || 0;
        const pcs = pcsNum ? `${pcsNum}세트` : "";

        // set effect text (prefer API payload; fallback to static rune meta if available)
        const effText = getRuneSetEffectText(setNameRaw, pcsNum, s);
        const effHtml = (effText && String(effText).trim())
          ? `<div class="rune-set-eff muted" data-has-effect="1">${formatDescText(escapeHtml(String(effText)))}</div>`
          : `<div class="rune-set-eff muted" data-has-effect="0" data-effect-pieces="${escapeHtml(String(pcsNum||0))}"></div>`;

        const setKey = slugKey(setNameRaw);

        return `<div class="rune-set" data-setkey="${escapeHtml(setKey)}" data-pieces="${escapeHtml(String(pcsNum||0))}">
          ${icon}
          <div class="rune-set-meta">
            <div class="rune-set-name">${name}</div>
            <div class="rune-set-pcs muted">${escapeHtml(pcs)}</div>
            ${effHtml}
          </div>
        </div>`;
      }

      function renderSlots
(slots){
        if (!slots || typeof slots !== "object") return "";
        const keys = Object.keys(slots).sort((a,b)=>Number(a)-Number(b));
        const rows = keys.map(k=>{
          const v = slots[k];
          const list = Array.isArray(v) ? v : (typeof v === "string" ? [v] : []);
          const html = list.length ? list.map(x => `<div class="slot-item">${formatDescText(escapeHtml(String(x)))}</div>`).join("")
                                   : `<div class="slot-item muted">-</div>`;
          return `<div class="slot-row"><div class="slot-k">${escapeHtml(String(k))}번</div><div class="slot-v">${html}</div></div>`;
        }).join("");
        return `<div class="rune-slots">${rows}</div>`;
      }

      function renderList(title, arr) {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return "";
        return `
          <div class="rune-list">
            <div class="rune-list-title">${escapeHtml(title)}</div>
            <ul class="rune-ul">
              ${arr.map(x => `<li>${formatDescText(escapeHtml(String(x)))}</li>`).join("")}
            </ul>
          </div>`;
      }

      function renderBuildCard(b){
        const sets = (b && Array.isArray(b.setPlan)) ? b.setPlan : [];
        const title = escapeHtml(String(b && b.title ? b.title : "추천"));
        const score = (b && (b.score !== undefined && b.score !== null)) ? `<span class="rune-score muted">score: ${escapeHtml(String(b.score))}</span>` : "";
        const notes = Array.isArray(b && b.notes) ? b.notes : [];
        const rationale = Array.isArray(b && b.rationale) ? b.rationale : [];
        const slots = (b && b.slots) ? b.slots : null;
        const substats = Array.isArray(b && b.substats) ? b.substats : [];

        return `
          <div class="rune-build-card">
            <div class="rune-build-head">
              <div class="rune-build-title">${title}</div>
              ${score}
            </div>

            <div class="rune-set-grid">
              ${sets.map(renderSetItem).join("")}
            </div>

            ${substats.length ? `<div class="rune-substats">
              <div class="rune-list-title">우선 부옵션</div>
              <div class="rune-chip-row">${substats.map(x=>`<span class="chip">${escapeHtml(String(x))}</span>`).join("")}</div>
            </div>` : ""}

            ${slots ? `<div class="rune-list-title" style="margin-top:10px">메인 옵션</div>${renderSlots(slots)}` : ""}

            ${renderList("참고/주의", notes)}
            ${renderList("추천 근거", rationale)}
          </div>
        `;
      }

      function renderBuilds(builds){
        if (!builds) return `<div class="detail-empty">추천 룬 정보가 없습니다.</div>`;
        return `<div class="rune-builds">${builds.map(renderBuildCard).join("")}</div>`;
      }

      if (!runeReco) return `<div class="detail-empty">추천 룬 정보가 없습니다.</div>`;

      if (!isBoth) {
        const builds = pickBuilds(runeReco);
        return renderBuilds(builds);
      }

      // both: show BOTH / PVE / PVP mode segment
      const pveBuilds = pickBuilds(runeReco.pve);
      const pvpBuilds = pickBuilds(runeReco.pvp);

      // default mode: BOTH (요청사항: 기본 both)
      return `
        <div class="rune-reco" data-rune-mode="both">
          <div class="rune-seg">
            <button type="button" class="rune-seg-btn active" data-mode="both">BOTH</button>
            <button type="button" class="rune-seg-btn" data-mode="pve">PVE</button>
            <button type="button" class="rune-seg-btn" data-mode="pvp">PVP</button>
          </div>

          <div class="rune-mode-panel active" data-panel="both">
            <div class="rune-grid-col">
              <div class="rune-sec-title">PVE</div>
              ${renderBuilds(pveBuilds)}
              <div class="rune-sec-title" style="margin-top:14px;">PVP</div>
              ${renderBuilds(pvpBuilds)}
            </div>
          </div>

          <div class="rune-mode-panel" data-panel="pve" style="display:none">
            ${renderBuilds(pveBuilds)}
          </div>
          <div class="rune-mode-panel" data-panel="pvp" style="display:none">
            ${renderBuilds(pvpBuilds)}
          </div>
        </div>
      `;
    }


    function renderDetailTabs(detail, runeReco) {
      const tabs = [
        { id: "skills", label: "스킬", content: renderSkills(detail) },
        { id: "awakenings", label: "각성", content: renderAwakenings(detail) },
        { id: "memory", label: "메모리카드", content: renderMemoryCard(detail) },
        { id: "runes", label: "추천 룬", content: renderRecommendedRunes(runeReco) },
      ];
      const firstActive = "skills";

      const tabBtns = tabs.map(t =>
        `<button type="button" class="tab-btn ${t.id === firstActive ? "active" : ""}" data-tab="${escapeHtml(t.id)}">${escapeHtml(t.label)}</button>`
      ).join("");

      const panels = tabs.map(t => renderPanel(t.id, t.content, t.id === firstActive)).join("");

      return `
        <div class="tabs">
          <div class="tab-buttons">${tabBtns}</div>
          <div class="tab-panels">${panels}</div>
        </div>
      `;
    }

    
    function bindTabEvents() {
      const root = document.getElementById("modalBody");
      if (!root) return;
      root.onclick = (e) => {
        // detail tabs
        const tabBtn = e.target.closest(".tab-btn");
        if (tabBtn) {
          const tab = tabBtn.dataset.tab;
          if (!tab) return;
          root.querySelectorAll(".tab-btn").forEach(b => b.classList.toggle("active", b.dataset.tab === tab));
          root.querySelectorAll(".tab-panel").forEach(p => p.classList.toggle("active", p.dataset.panel === tab));
          return;
        }

        // rune mode segment (BOTH / PVE / PVP) inside "추천 룬" tab
        // - supports both new(.rune-seg-btn/.rune-reco/.active) and legacy(.seg-btn/.rune-mode-wrap/.is-active)
        const segBtn = e.target.closest(".rune-seg-btn, .seg-btn");
        if (segBtn) {
          const mode = segBtn.dataset.mode;
          const wrap = segBtn.closest(".rune-reco, .rune-mode-wrap");
          if (!wrap || !mode) return;

          wrap.dataset.runeMode = mode;

          // 버튼 활성화
          wrap.querySelectorAll(".rune-seg-btn, .seg-btn").forEach(b => {
            const on = b.dataset.mode === mode;
            b.classList.toggle("active", on);
            b.classList.toggle("is-active", on);
          });

          // 패널 표시
          wrap.querySelectorAll(".rune-mode-panel").forEach(p => {
            const isOn = p.dataset.panel === mode;
            p.classList.toggle("active", isOn);
            p.style.display = isOn ? "" : "none"; // inline wins for legacy; empty lets CSS(.active) show
          });

          return;
        }
      };
    }


    // ===== Modal open/close =====
    const backdrop = document.getElementById("modalBackdrop");
    const modalBody = document.getElementById("modalBody");
    const modalTitle = document.getElementById("modalTitle");
    const modalClose = document.getElementById("modalClose");

    function openModal() {
      backdrop.classList.add("show");
      backdrop.setAttribute("aria-hidden", "false");
    }
    function closeModal() {
      backdrop.classList.remove("show");
      backdrop.setAttribute("aria-hidden", "true");
      modalBody.innerHTML = `<div class="modal-loading">Loading…</div>`;
    }
    modalClose.addEventListener("click", closeModal);
    backdrop.addEventListener("click", (e) => { if (e.target === backdrop) closeModal(); });
    document.addEventListener("keydown", (e) => { if (e.key === "Escape" && backdrop.classList.contains("show")) closeModal(); });

    function setModalTitle(name, cn){
      const safeName = escapeHtml(name || "Character");
      const safeCn = cn ? escapeHtml(cn) : "";
      modalTitle.innerHTML = safeCn ? `${safeName}<span class="cn">${safeCn}</span>` : safeName;
    }

    async function fetchAndOpen(cid) {
      openModal();
      modalBody.innerHTML = `<div class="modal-loading">Loading…</div>`;
      try {
        const r = await fetch(`/zones/zone-nova/characters/${encodeURIComponent(cid)}`, { cache: "no-store" });
        const j = await r.json();
        if (!j.ok) {
          modalBody.innerHTML = `<div class="detail-empty">불러오기 실패: ${escapeHtml(j.error || "unknown")}</div>`;
          return;
        }

        const detail = j.detail || {};
        const name = pick(detail, "name") || j.character?.name || j.id || "Character";
        const cn = pick(detail, "chineseName", "chinesename", "chinessname", "cnName", "cn_name");

        setModalTitle(name, cn);
        const runeReco = j.rune_reco || null;
        modalBody.innerHTML = renderDetailTabs(detail, runeReco);
        bindTabEvents();
        try { hydrateRuneSetEffects(modalBody); } catch(e) {}
      } catch (e) {
        modalBody.innerHTML = `<div class="detail-empty">불러오기 실패: ${escapeHtml(String(e))}</div>`;
      }
    }

    // ===== JS error banner =====
    (function(){
      const banner = document.getElementById('jsErrorBanner');
      const text = document.getElementById('jsErrorText');
      if (!banner || !text) return;
      function show(msg){
        text.textContent = String(msg || 'unknown');
        banner.style.display = 'block';
      }
      window.addEventListener('error', (e) => { show(e?.message || e); });
      window.addEventListener('unhandledrejection', (e) => { show(e?.reason || e); });
    })();

    // ===== List render =====
    function dedupeById(list){
      const m = new Map();
      for (const c of (list || [])){
        if (!c) continue;
        const id = (c.id || "").toString().trim();
        if (!id) continue;
        if (!m.has(id)) m.set(id, c);
      }
      return Array.from(m.values());
    }

    const chars = dedupeById(CHARS_RAW || []);

    const $tbody = document.getElementById("tbody");
    const $q = document.getElementById("q");
    const $rarity = document.getElementById("rarityFilter");
    const $elem = document.getElementById("elemFilter");
    const $faction = document.getElementById("factionFilter");
    const $class = document.getElementById("classFilter");
    const $role = document.getElementById("roleFilter");
function uniqSorted(values){
      return Array.from(new Set(values.filter(v => v && v !== "-")))
        .sort((a,b) => a.localeCompare(b));
    }
    function fillSelect(sel, values){
      for (const v of values){
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v;
        sel.appendChild(opt);
      }
    }

    fillSelect($elem, uniqSorted(chars.map(c => (c.element || "-"))));
    fillSelect($faction, uniqSorted(chars.map(c => (c.faction || "-"))));
    fillSelect($class, uniqSorted(chars.map(c => classLabel(c.class))));
    fillSelect($role, uniqSorted(chars.map(c => roleLabel(c.role))));

    function matchFilters(c){
      const q = ($q.value || "").trim().toLowerCase();
      const rarityV = ($rarity.value || "").trim().toUpperCase();
      const elemV = ($elem.value || "").trim();
      const factionV = ($faction.value || "").trim();
      const classV = ($class.value || "").trim();
      const roleV = ($role.value || "").trim();

      const name = (c.name || "").toString().toLowerCase();
      const id = (c.id || "").toString().toLowerCase();
      const faction = (c.faction || "-").toString().toLowerCase();
      const elem = (c.element || "-").toString();

      if (q){
        const ok = name.includes(q) || id.includes(q) || faction.includes(q) || elem.toLowerCase().includes(q);
        if (!ok) return false;
      }
      if (rarityV && (c.rarity || "-").toString().toUpperCase() !== rarityV) return false;
      if (elemV && (c.element || "-") !== elemV) return false;
      if (factionV && (c.faction || "-") !== factionV) return false;
      if (classV && classLabel(c.class) !== classV) return false;
      if (roleV && roleLabel(c.role) !== roleV) return false;
      return true;
    }

    function sortChars(list){
      return list.slice().sort((a,b) => {
        const ra = rarityVal(a.rarity);
        const rb = rarityVal(b.rarity);
        if (rb !== ra) return rb - ra;
        const na = (a.name || a.id || "").toString();
        const nb = (b.name || b.id || "").toString();
        return na.localeCompare(nb);
      });
    }

    
    // ===== Stats (HP/ATK/DEF) loaded from /data/zone-nova/characters_ko/<id>.json =====
    const STAT_CACHE = new Map(); // cid -> {hp, attack, defense}

    async function fetchStats(cid){
      if (!cid) return null;
      if (STAT_CACHE.has(cid)) return STAT_CACHE.get(cid);

      // Try common static paths
      
      const cidStr = String(cid);
      const cidKey = slugKey(cidStr);
      // filename overrides (test case)
      const OV_FILE = (cidKey === "aphrodite") ? "afrodite" : null;

const enc = encodeURIComponent(String(cid));
      const encLower = encodeURIComponent(String(cid).toLowerCase());
      const candidates = [
        ...(OV_FILE ? [
          `/data/zone-nova/characters_ko/${encodeURIComponent(OV_FILE)}.json`,
          `/public/data/zone-nova/characters_ko/${encodeURIComponent(OV_FILE)}.json`,
        ] : []),

        `/data/zone-nova/characters_ko/${enc}.json`,
        `/data/zone-nova/characters_ko/${encLower}.json`,
        `/public/data/zone-nova/characters_ko/${enc}.json`,
        `/public/data/zone-nova/characters_ko/${encLower}.json`,
      ];

      for (const url of candidates){
        try{
          const r = await fetch(url, { cache: "no-store" });
          if (!r.ok) continue;
          const j = await r.json();
          
          const s = (j && typeof j === "object" && j.stats && typeof j.stats === "object") ? j.stats : j;
        const hp = pick(s, "hp", "HP");
        const defense = pick(s, "defense", "def", "DEF");
        const attack = pick(s, "attack", "atk", "ATK");
        const critRate = pick(s, "critRate", "crit_rate", "criticalRate", "crit"); // 호환
        
        const stats = {
          hp: hp ?? "-",
          attack: attack ?? "-",
          defense: defense ?? "-",
          critRate: critRate ?? "-",
        };
          STAT_CACHE.set(cid, stats);
          return stats;
        }catch(e){}
      }

      // cache miss
     const stats = { hp: "-", attack: "-", defense: "-", critRate: "-" };
      STAT_CACHE.set(cid, stats);
      return stats;
    }

    function fillStatsForVisibleRows(){
      // fetch stats asynchronously for rendered rows
      const cells = document.querySelectorAll('td[data-stat][data-cid]');
      const need = new Set();
      cells.forEach(td => {
        const cid = td.dataset.cid;
        if (cid && !STAT_CACHE.has(cid)) need.add(cid);
      });
      // fire and forget
      need.forEach(async (cid) => {
        const stats = await fetchStats(cid);
        document.querySelectorAll(`td[data-stat][data-cid="${CSS.escape(cid)}"]`).forEach(td => {
          const k = td.dataset.stat;
          const v = stats?.[k] ?? "-";
        td.textContent = formatStatDisplay(k, v);
        });
      });

      // fill already cached
      cells.forEach(td => {
        const cid = td.dataset.cid;
        const k = td.dataset.stat;
        const st = STAT_CACHE.get(cid);
        if (st && st[k] !== undefined) td.textContent = String(st[k]);
      });
    }
    // ===== Stats sorting by header click =====
    const SORT_STATE = { key: null, dir: "desc" }; // key: hp|attack|defense|null, dir: asc|desc

    function formatStatDisplay(key, v){
      if (v === null || v === undefined) return "-";
      const s = String(v).trim();
      if (s === "" || s === "-") return "-";
    
      if (key === "critRate"){
        // 이미 %가 있으면 그대로, 숫자면 % 붙이기
        if (s.includes("%")) return s;
        const n = Number(s.replace(/,/g, ""));
        return Number.isFinite(n) ? `${n}%` : s;
      }
      return s;
    }
    
    function statNum(v){
      if (v === null || v === undefined) return -1;
      const n = Number(String(v).replace(/,/g, "").replace(/%/g, ""));
      return Number.isFinite(n) ? n : -1;
    }

    function updateStatHeaderIndicators(){
      document.querySelectorAll("th.th-sort").forEach(th => {
        th.classList.remove("sort-asc", "sort-desc");
        if (SORT_STATE.key && th.dataset.sort === SORT_STATE.key){
          th.classList.add(SORT_STATE.dir === "asc" ? "sort-asc" : "sort-desc");
        }
      });
    }



async function render(){
      
      const base = chars.filter(matchFilters);

      // Sort: default (rarity/name) or stats(header)
      let filtered = [];
      if (SORT_STATE.key === "hp" || SORT_STATE.key === "defense" || SORT_STATE.key === "attack" || SORT_STATE.key === "critRate") {
        const ids = base.map(c => c.id).filter(Boolean);
        await Promise.all(ids.map(cid => fetchStats(cid)));
        filtered = base.slice().sort((a,b) => {
          const sa = STAT_CACHE.get(a.id);
          const sb = STAT_CACHE.get(b.id);
          const va = statNum(sa?.[SORT_STATE.key]);
          const vb = statNum(sb?.[SORT_STATE.key]);
          if (va !== vb) {
            return (SORT_STATE.dir === "asc") ? (va - vb) : (vb - va);
          }
          // tie-breakers: rarity then name
          const ra = rarityVal(a.rarity);
          const rb = rarityVal(b.rarity);
          if (rb !== ra) return rb - ra;
          const na = (a.name || a.id || "").toString();
          const nb = (b.name || b.id || "").toString();
          return na.localeCompare(nb);
        });
      } else {
        filtered = sortChars(base);
      }

      updateStatHeaderIndicators();

const rows = filtered.map(c => {
        const cid = c.id;
        const nm = c.name || cid;

        const elem = (c.element || "-");
        const faction = (c.faction || "-");
        const cls = classLabel(c.class);
        const role = roleLabel(c.role);
        const rar = (c.rarity || "-").toString().toUpperCase();

        const img = c.image
          ? `<img class="char-img" src="${escapeHtml(c.image)}" alt="">`
          : `<div class="char-img"></div>`;

        const elemIcon = c.element_icon ? `<img class="mini-icon" src="${escapeHtml(c.element_icon)}" alt="">` : "";
        const classIcon = c.class_icon ? `<img class="mini-icon" src="${escapeHtml(c.class_icon)}" alt="">` : "";

        return `
          <tr>
            <td class="col-check">
  <div class="pick-stack">
    <label class="pick-line" title="보유(선택) 캐릭터로 포함">
      <input class="chk-owned" type="checkbox" data-cid="${escapeHtml(cid)}">
      <span class="pick-text">선택</span>
    </label>
    <label class="pick-line" title="추천 파티에 반드시 포함(파티 지정 가능)">
      <input class="chk-must" type="checkbox" data-cid="${escapeHtml(cid)}">
      <span class="pick-text">필수</span>
    </label>
    <select class="must-slot" data-cid="${escapeHtml(cid)}" disabled title="필수 배치(자동 또는 특정 파티 지정)"></select>
    <select class="must-role" data-cid="${escapeHtml(cid)}" disabled title="역할 고정(자동/탱커/딜러/힐러/버퍼/디버퍼)"></select>
  </div>
</td>
<td class="col-char">
              <div class="char-cell clickable" data-cid="${escapeHtml(cid)}">
                ${img}
                <div class="char-name">${escapeHtml(nm)}</div>
              </div>
            </td>
           <td class="col-hp" data-stat="hp" data-cid="${escapeHtml(cid)}">-</td>
           <td class="col-def" data-stat="defense" data-cid="${escapeHtml(cid)}">-</td>
           <td class="col-atk" data-stat="attack" data-cid="${escapeHtml(cid)}">-</td>
           <td class="col-crit" data-stat="critRate" data-cid="${escapeHtml(cid)}">-</td>

            <td class="col-elem">
              <span class="pill pill-neutral pill-with-icon">
                ${elemIcon}
                <span class="pill-text">${escapeHtml(elem)}</span>
              </span>
            </td>
            <td class="col-faction"><span class="pill pill-neutral">${escapeHtml(faction)}</span></td>
            <td class="col-class">
              <span class="pill pill-neutral pill-with-icon">
                ${classIcon}
                <span class="pill-text">${escapeHtml(cls)}</span>
              </span>
            </td>
            <td class="col-role"><span class="pill pill-neutral">${escapeHtml(role)}</span></td>
            <td class="col-rarity"><span class="pill ${rarityPillClass(rar)}">${escapeHtml(rar)}</span></td>
          </tr>
        `;
      }).join("");

      $tbody.innerHTML = rows || `<tr><td colspan="11" style="padding:18px;color:rgba(255,255,255,.70);font-weight:800;">표시할 캐릭터가 없습니다.</td></tr>`;
    
      fillStatsForVisibleRows();
      initMustControlsForVisibleRows();
    }

    [$q, $rarity, $elem, $faction, $class, $role].forEach(el => {
      el.addEventListener("input", render);
      el.addEventListener("change", render);
    });

    document.getElementById("btnAll").addEventListener("click", () => {
      document.querySelectorAll(".chk-owned").forEach(x => x.checked = true);
    });
    document.getElementById("btnNone").addEventListener("click", () => {
      document.querySelectorAll(".chk-owned").forEach(x => x.checked = false);

// 필수(파티 지정)도 초기화
MUST_STATE = {};
saveMustState();
document.querySelectorAll(".chk-must").forEach(x => x.checked = false);
document.querySelectorAll(".must-slot").forEach(s => { s.value = ""; s.disabled = true; });
document.querySelectorAll(".must-role").forEach(s => { s.value = ""; s.disabled = true; });
});

// ✅ 파티 결과만 초기화 (선택/필수 체크는 유지)
document.getElementById("btnResetParties")?.addEventListener("click", () => {
  const tierBox = document.getElementById("tierPartyResult");
  const aiBox = document.getElementById("aiPartyResult");
  if (tierBox) tierBox.innerHTML = "";
  if (aiBox) aiBox.innerHTML = "";
});



// ✅ 보유(선택) ↔ 필수(파티 지정) 동기화
// - 필수 체크 시: 보유도 자동 체크
// - 보유 해제 시: 필수 해제 + 배치 초기화(MUST_STATE도 반영)
document.addEventListener("change", (e) => {
  const t = e.target;
  if (!t || !t.classList) return;

  if (t.classList.contains("chk-must")){
    const cid = t.dataset.cid;
    if (!cid) return;

    if (t.checked){
      const owned = document.querySelector(`.chk-owned[data-cid="${cssEsc(cid)}"]`);
      if (owned) owned.checked = true;
    }
    // MUST_STATE는 initMustControlsForVisibleRows()의 개별 핸들러에서 저장/초기화
    return;
  }

  if (t.classList.contains("chk-owned")){
    const cid = t.dataset.cid;
    if (!cid) return;

    // 보유 해제하면 필수도 해제 + 배치 초기화
    if (!t.checked){
      const must = document.querySelector(`.chk-must[data-cid="${cssEsc(cid)}"]`);
      const slot = document.querySelector(`.must-slot[data-cid="${cssEsc(cid)}"]`);
      const roleSel = document.querySelector(`.must-role[data-cid="${cssEsc(cid)}"]`);

      if (must) must.checked = false;
      if (slot){
        slot.value = "";
        slot.disabled = true;
      }
      if (roleSel){
        roleSel.value = "";
        roleSel.disabled = true;
      }

      if (MUST_STATE && MUST_STATE[cid]){
        MUST_STATE[cid].on = false;
        MUST_STATE[cid].target = "";
        MUST_STATE[cid].role = "";
        saveMustState();
      }
    }
    return;
  }
});


    document.addEventListener("click", (e) => {
      const chk = e.target.closest(".chk-owned");
      if (chk) return;
      const cell = e.target.closest(".char-cell.clickable");
      if (!cell) return;
      const cid = cell.dataset.cid;
      if (cid) fetchAndOpen(cid);
    });

    render();


    // Click stat headers to sort (toggle asc/desc)
    (function bindStatHeaderSort(){
      const table = document.querySelector(".table");
      if (!table) return;
      const thead = table.querySelector("thead");
      if (!thead) return;
      thead.addEventListener("click", (e) => {
        const th = e.target.closest("th.th-sort");
        if (!th) return;
        const key = th.dataset.sort;
        if (!key) return;
        if (SORT_STATE.key === key) SORT_STATE.dir = (SORT_STATE.dir === "asc") ? "desc" : "asc";
        else { SORT_STATE.key = key; SORT_STATE.dir = "desc"; }
        render();
      });
    })();

    // ===== Filters collapse (mobile) =====
    // - 모바일에서는 기본 접힘
    // - 사용자가 한 번 열고/닫으면 localStorage로 기억
    (function initFiltersCollapse(){
      const d = document.getElementById("filtersPanel");
      if (!d) return;

      const KEY = "nova_filters_open";
      const mq = window.matchMedia("(max-width: 520px)");

      const applyDefault = () => {
        if (mq.matches) d.removeAttribute("open");
        else d.setAttribute("open", "");
      };

      const saved = localStorage.getItem(KEY);
      if (saved === "1") d.setAttribute("open", "");
      else if (saved === "0") d.removeAttribute("open");
      else applyDefault();

      d.addEventListener("toggle", () => {
        localStorage.setItem(KEY, d.open ? "1" : "0");
      });

      mq.addEventListener?.("change", () => {
        // 저장값이 없을 때만 자동 적용(사용자 선택을 덮어쓰지 않음)
        if (localStorage.getItem(KEY) == null) applyDefault();
      });
    })();

    // ===== Tier Party Builder =====
    let ALL_TIER_LISTS = null;
    const TIER_SCORE = { SSS: 4, SS: 3, S: 2, A: 1 };

    function keyify(s){
      return slugKey(s);
    }

    // key -> [id...] (동명이인/오버라이드 충돌 대비)
    function buildCharIndex(chars){
      const byKey = new Map();
      const byId = new Map((chars || []).map(c => [String(c.id), c]));

      function addKey(key, id){
        if (!key || !id) return;
        const arr = byKey.get(key) || [];
        if (!arr.includes(id)) arr.push(id);
        // SSR 우선 정렬(있어도 되고 없어도 되지만, 일관성 위해 유지)
        arr.sort((a,b) => rarityVal(byId.get(b)?.rarity) - rarityVal(byId.get(a)?.rarity));
        byKey.set(key, arr);
      }

      for (const c of (chars || [])){
        if (!c?.id) continue;
        const id = String(c.id);
        if (c.name) addKey(keyify(c.name), id);
        if (c.raw_name) addKey(keyify(c.raw_name), id);
        addKey(keyify(id), id);
      }
      return { byKey };
    }

    // ✅ 동일 name이 여러 id로 매핑되면 "전부" rankMap에 반영
    function buildRankMapFromTierList(tierList, chars){
      const { byKey } = buildCharIndex(chars);
      const rank = new Map();
      const tiers = tierList?.tiers || {};

      for (const [tier, arr] of Object.entries(tiers)){
        const T = String(tier).toUpperCase();
        if (!TIER_SCORE[T]) continue;

        const list = Array.isArray(arr) ? arr : [];
        for (const it of list){
          const nm = (it && typeof it === "object") ? it.name : null;
          const ids = byKey.get(keyify(nm));
          if (!ids || !ids.length) continue;

          for (const cid of ids){
            const prev = rank.get(cid) || 0;
            rank.set(cid, Math.max(prev, TIER_SCORE[T]));
          }
        }
      }
      return rank;
    }

    function getOwnedSelectedIds(){
      const out = [];
      document.querySelectorAll(".chk-owned").forEach(chk => {
        if (chk.checked && chk.dataset.cid) out.push(chk.dataset.cid);
      });
      return out;
    }


function cssEsc(s){
  try{
    if (window.CSS && typeof CSS.escape === 'function') return CSS.escape(String(s));
  }catch(e){}
  return String(s).replace(/[^a-zA-Z0-9_\-]/g, (m)=>`\\${m}`);
}

function mustOptionHTML(){
  const groups = [
    { name:"PVE",   n:1 },
    { name:"PVP",   n:2 },
    { name:"Guild", n:3 },
    { name:"Rift",  n:2 },
  ];
  let html = `<option value="">자동</option>`;
  for (const g of groups){
    html += `<optgroup label="${escapeHtml(g.name)}">`;
    for (let i=1; i<=g.n; i++){
      html += `<option value="${escapeHtml(g.name+":"+i)}">${escapeHtml(i+"파티")}</option>`;
    }
    html += `</optgroup>`;
  }
  // legacy: Left (과거 저장값)
  html += `<optgroup label="Left(legacy)">`;
  for (let i=1; i<=2; i++){
    html += `<option value="Left:${i}">${i}파티</option>`;
  }
  html += `</optgroup>`;
  return html;
}


function mustRoleOptionHTML(){
  // 역할 고정: 추천 알고리즘에서 "이 캐릭터를 어떤 역할로 취급할지"를 사용자가 지정
  return `
    <option value="">자동</option>
    <option value="Tank">Tank</option>
    <option value="DPS">DPS</option>
    <option value="Healer">Healer</option>
    <option value="Buffer">Buffer</option>
    <option value="Debuffer">Debuffer</option>
  `;
}



function initMustControlsForVisibleRows(){
  const optionHTML = mustOptionHTML();
  const roleHTML = mustRoleOptionHTML();

  document.querySelectorAll(".must-slot").forEach(sel => {
    const cid = sel.dataset.cid || "";
    if (!cid) return;

    sel.innerHTML = optionHTML;

    const roleSel = document.querySelector(`.must-role[data-cid="${cssEsc(cid)}"]`);
    if (roleSel) roleSel.innerHTML = roleHTML;

    const chk = document.querySelector(`.chk-must[data-cid="${cssEsc(cid)}"]`);
    const st = MUST_STATE[cid] || { on:false, target:"", role:"" };

    if (chk){
      chk.checked = !!st.on;

      // 배치/역할 드롭다운 초기상태 반영
      sel.disabled = !chk.checked;
      sel.value = st.target || "";

      if (roleSel){
        roleSel.disabled = !chk.checked;
        roleSel.value = st.role || "";
      }

      // 이벤트 중복 바인딩 방지
      if (!chk.dataset.bound){
        chk.addEventListener("change", () => {
          const on = chk.checked;

          MUST_STATE[cid] = MUST_STATE[cid] || { on:false, target:"", role:"" };
          MUST_STATE[cid].on = on;

          if (!on){
            MUST_STATE[cid].target = "";
            MUST_STATE[cid].role = "";
            sel.value = "";
            sel.disabled = true;

            if (roleSel){
              roleSel.value = "";
              roleSel.disabled = true;
            }
          }else{
            // 필수 체크 시: owned도 켜고 드롭다운 활성화
            const owned = document.querySelector(`.chk-owned[data-cid="${cssEsc(cid)}"]`);
            if (owned) owned.checked = true;

            sel.disabled = false;
            if (roleSel) roleSel.disabled = false;
          }

          saveMustState();
        });
        chk.dataset.bound = "1";
      }

      if (!sel.dataset.bound){
        sel.addEventListener("change", () => {
          const v = String(sel.value || "");
          MUST_STATE[cid] = MUST_STATE[cid] || { on:false, target:"", role:"" };
          MUST_STATE[cid].on = true;
          MUST_STATE[cid].target = v;
          saveMustState();

          const chk2 = document.querySelector(`.chk-must[data-cid="${cssEsc(cid)}"]`);
          if (chk2) chk2.checked = true;
          sel.disabled = false;

          if (roleSel) roleSel.disabled = false;
          const owned = document.querySelector(`.chk-owned[data-cid="${cssEsc(cid)}"]`);
          if (owned) owned.checked = true;
        });
        sel.dataset.bound = "1";
      }

      if (roleSel && !roleSel.dataset.bound){
        roleSel.addEventListener("change", () => {
          const v = String(roleSel.value || "");
          MUST_STATE[cid] = MUST_STATE[cid] || { on:false, target:"", role:"" };
          MUST_STATE[cid].on = true;
          MUST_STATE[cid].role = v;
          saveMustState();

          const chk2 = document.querySelector(`.chk-must[data-cid="${cssEsc(cid)}"]`);
          if (chk2) chk2.checked = true;

          sel.disabled = false;
          roleSel.disabled = false;

          const owned = document.querySelector(`.chk-owned[data-cid="${cssEsc(cid)}"]`);
          if (owned) owned.checked = true;
        });
        roleSel.dataset.bound = "1";
      }
    }
  });
}


function getMustSelectedIds(){
  // MUST_STATE 기반(지속 저장) + 현재 화면 체크 보강
  const out = new Set();
  for (const [cid, st] of Object.entries(MUST_STATE || {})){
    if (st && st.on) out.add(cid);
  }
  document.querySelectorAll(".chk-must").forEach(chk => {
    if (chk.checked && chk.dataset.cid) out.add(chk.dataset.cid);
  });
  return Array.from(out);
}


function getMustOverrides(){
  // 서버로 전달할 "필수 캐릭터별 배치/역할 지정" 정보
  const out = {};
  for (const [cid, st] of Object.entries(MUST_STATE || {})){
    if (!st || !st.on) continue;
    const target = String(st.target || "");
    const role = String(st.role || "");
    if (target || role) out[cid] = { target, role };
  }
  return out;
}



function getMustAssignments(){
  const byCategory = { PVE:[[]], PVP:[[],[]], Guild:[[],[],[]], Rift:[[],[]] };
  const auto = [];

  const canon = (cat) => {
    const c = String(cat||"").trim();
    if (!c) return "";
    const u = c.toUpperCase();
    if (u === "LEFT" || u === "RIFT") return "Rift";
    if (u === "GUILD" || u === "GUILDRAID" || u === "GUILD_RAID") return "Guild";
    if (u === "PVE") return "PVE";
    if (u === "PVP") return "PVP";
    return c;
  };

  for (const [cid, st] of Object.entries(MUST_STATE || {})){
    if (!st || !st.on) continue;

    const target = String(st.target || "");
    if (!target){ auto.push(cid); continue; }

    const [catRaw, idxStr] = target.split(":");
    const cat = canon(catRaw);
    const i = parseInt(idxStr, 10);
    if (!cat || !i) { auto.push(cid); continue; }

    if (byCategory[cat] && byCategory[cat][i-1]){
      byCategory[cat][i-1].push(cid);
    }else{
      auto.push(cid);
    }
  }

  return { auto, byCategory };
}

function getRankMapObjectForCurrentPreset(){
  const sel = document.getElementById("tierPreset");
  if (!sel || !ALL_TIER_LISTS) return {};
  const k = sel.value;
  if (!k || !ALL_TIER_LISTS[k]) return {};
  const rankMap = buildRankMapFromTierList(ALL_TIER_LISTS[k], chars);
  const obj = {};
  rankMap.forEach((v, key) => { obj[key] = v; });
  return obj;
}

function renderAiPartyResult(res){
  const box = document.getElementById("aiPartyResult");
  if (!box) return;

  if (!res || !res.ok){
    const msg = escapeHtml(String(res?.error || res?.msg || "추천 결과를 불러오지 못했습니다."));
    box.innerHTML = `<div class="tier-error">${msg}</div>`;
    return;
  }

  // ✅ multi groups format: { groups: { Guild:[party...], PVP:[...], Left:[...] }, warnings:[...] }
  const groups = (res.groups && typeof res.groups === "object") ? res.groups : null;

  const renderPartyBlock = (title, party, idx) => {
    const mems = Array.isArray(party?.members) ? party.members : [];
    const meta = party?.meta || {};
    const counts = meta?.counts || {};
    const combo = meta?.combo_detail || {};
    const cmode = meta?.combo_mode || res.combo_mode || "";

    const metaLines = [
      `총점: <b>${escapeHtml(String(Math.round((party?.total_score||0)*10)/10))}</b>`,
      `구성: 탱 ${escapeHtml(String(counts.tank||0))} / 힐 ${escapeHtml(String(counts.healer||0))} / 딜 ${escapeHtml(String(counts.dps||0))} / 버퍼 ${escapeHtml(String(counts.buffer||0))} / 디버퍼 ${escapeHtml(String(counts.debuffer||0))}`,
      `콤보(${escapeHtml(String(cmode||""))}): 속성 ${escapeHtml(String((combo.element_hits||[]).join(", ")||"-"))} / 특성 ${escapeHtml(String((combo.faction_hits||[]).join(", ")||"-"))}`,
    ].join(" · ");

    const cards = mems.map(m => {
      const img = m?.image
        ? `<img class="tier-portrait" src="${escapeHtml(m.image)}" alt="">`
        : `<div class="tier-portrait tier-portrait-empty"></div>`;

      return `
        <div class="tier-card">
          <div class="tier-card-top">
            ${img}
            <span class="tier-name">${escapeHtml(m?.name || m?.id || "-")}</span>
          </div>
          <div class="tier-card-sub">
            <span class="pill pill-neutral">${escapeHtml(m?.element || "-")}</span>
            <span class="pill pill-neutral">${escapeHtml(m?.faction || "-")}</span>
            <span class="pill pill-neutral">${escapeHtml(m?.class || "-")}</span>
            <span class="pill pill-neutral">${escapeHtml(m?.archetype || m?.role || "-")}</span>
            <span class="pill">${escapeHtml(String(m?.tier ?? "-"))}</span>
          </div>
        </div>
      `;
    }).join("");

    return `
      <div class="tier-cat">
        <div class="tier-cat-title">${escapeHtml(title)} ${escapeHtml(String(idx))}파티</div>
        <div class="tier-cat-meta">${metaLines}</div>
        <div class="tier-grid">${cards}</div>
      </div>
    `;
  };

  let out = "";

  // warnings
  if (Array.isArray(res.warnings) && res.warnings.length){
    out += `<div class="tier-warn">${res.warnings.map(w=>`<div>• ${escapeHtml(w)}</div>`).join("")}</div>`;
  }

  if (groups){
    const order = ["PVE", "PVP", "Guild", "Rift"];
    for (const cat of order){
      const arr = Array.isArray(groups[cat]) ? groups[cat] : [];
      if (!arr.length) continue;

      out += `<div class="tier-section-title">${escapeHtml(cat)}</div>`;
      arr.forEach((p, i) => { out += renderPartyBlock(cat, p, i+1); });
    }

    if (!out){
      out = `<div class="tier-error">추천 파티 데이터가 없습니다.</div>`;
    }

    box.innerHTML = out;
    return;
  }

  // ✅ backward compatibility (single)
  const party = (res.parties && res.parties[0]) ? res.parties[0] : null;
  if (!party){
    box.innerHTML = `<div class="tier-error">추천 파티 데이터가 없습니다.</div>`;
    return;
  }
  box.innerHTML = renderPartyBlock("AI 추천", party, 1);
}

async function requestAiParty(){
  const owned = getOwnedSelectedIds();
  const required = getMustSelectedIds();

  if (owned.length < 4){
    renderAiPartyResult({ ok:false, error:"보유(선택) 캐릭터가 4명 이상이어야 합니다." });
    return;
  }
  if (required.length > 4){
    renderAiPartyResult({ ok:false, error:"필수 포함은 최대 4명까지 가능합니다." });
    return;
  }

  // ✅ 등급표 기반 추천: 등급표 선택이 없으면 정확도가 크게 떨어지므로 차단
  const preset = document.getElementById("tierPreset")?.value || "";
  if (!preset){
    renderAiPartyResult({ ok:false, error:"등급표를 먼저 선택하세요. (좌측 드롭다운)" });
    return;
  }

  const classSet = getEnabledClassSet();
  const requiredClasses = classSet ? Array.from(classSet) : [];

  const category = (function(){
    const k = String(preset||"").trim().toLowerCase();
    if (k === "pve") return "PVE";
    if (k === "pvp") return "PVP";
    if (k === "guild" || k === "guild-raid" || k === "guildraid") return "Guild";
    if (k === "rift" || k === "left") return "Rift";
    return "";
  })();

  const payload = {
    owned,
    required,
    required_overrides: getMustOverrides(),
    must_assignments: getMustAssignments(), // PVE 1 / PVP 2 / Guild 3 / Rift 2 (+ 타겟 지정)
    required_classes: requiredClasses,
    rank_map: getRankMapObjectForCurrentPreset(),
    party_size: 4,
    top_k: 1,

    // ✅ 콤보는 하드 강제가 아니라 가산점으로 반영(실패/지연 방지)
    require_combo: false,
    combo_mode: "either", // 속성 2+ OR 특성 2+

    // ✅ 현재 등급표 프리셋 기준으로 "해당 카테고리"만 추천 (동일 카테고리 내 중복만 방지)
    multi: true,
    preset_key: preset,
    category,

    // ✅ 5초 내 끊기(서버 탐색 제한)
    time_limit_ms: 4800,
  };

  const box = document.getElementById("aiPartyResult");
  if (box) box.innerHTML = `<div class="tier-loading">AI 추천 계산중…</div>`;

  try {
    const r = await fetch("/zones/zone-nova/recommend", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    const ct = (r.headers.get("content-type") || "").toLowerCase();
    if (ct.includes("application/json")) {
      const j = await r.json();
      renderAiPartyResult(j);
    } else {
      const t = await r.text();
      renderAiPartyResult({ ok:false, error: "서버가 JSON이 아닌 응답을 반환했습니다. (라우트/서버 에러 가능)\n" + t.slice(0, 400) });
    }
  } catch (e){
    renderAiPartyResult({ ok:false, error: String(e?.message || e) });
  }
}


    function initTierClassCheckboxes(){
      const box = document.getElementById("tierClassBox");
      const use = document.getElementById("useClassFilter");
      if (!box || !use) return;

      const classes = Array.from(new Set((chars || []).map(c => String(c.class || "-")).filter(v => v && v !== "-")))
        .sort((a,b) => a.localeCompare(b));

      box.innerHTML = classes.map(cls => `
        <label class="tier-class-item">
          <input type="checkbox" value="${escapeHtml(cls)}" disabled>
          <span>${escapeHtml(cls)}</span>
        </label>
      `).join("");

      const toggle = () => {
        const on = !!use.checked;
        box.setAttribute("aria-disabled", String(!on));
        box.querySelectorAll("input[type=checkbox]").forEach(x => x.disabled = !on);
      };
      use.addEventListener("change", toggle);
      toggle();
    }

    function getEnabledClassSet(){
      const use = document.getElementById("useClassFilter")?.checked;
      if (!use) return null;

      const picked = new Set();
      document.querySelectorAll(".tier-class-item input[type=checkbox]").forEach(x => {
        if (x.checked) picked.add(x.value);
      });
      return picked.size ? picked : null;
    }

    function hasComboSkill(party, charsById){
      const elem = new Map();
      const fac = new Map();
      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) continue;
        const e = c.element || "-";
        const f = c.faction || "-";
        elem.set(e, (elem.get(e) || 0) + 1);
        fac.set(f, (fac.get(f) || 0) + 1);
      }
      const maxElem = Math.max(0, ...elem.values());
      const maxFac = Math.max(0, ...fac.values());
      return (maxElem >= 2) || (maxFac >= 2);
    }

    // ✅ 모든 파티원이 콤보(속성2+ 또는 특성2+)에 “참여”해야 함
    function allMembersContributeToCombo(party, charsById){
      const elemCount = new Map();
      const facCount = new Map();

      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) continue;
        const e = c.element || "-";
        const f = c.faction || "-";
        elemCount.set(e, (elemCount.get(e) || 0) + 1);
        facCount.set(f, (facCount.get(f) || 0) + 1);
      }

      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) return false;

        const e = c.element || "-";
        const f = c.faction || "-";

        const eOk = e !== "-" && (elemCount.get(e) || 0) >= 2;
        const fOk = f !== "-" && (facCount.get(f) || 0) >= 2;

        if (!eOk && !fOk) return false;
      }
      return true;
    }

    function isTank(c){
      const cls = String(c?.class || "").toLowerCase();
      const role = String(c?.role || "").toLowerCase();
      return cls === "guardian" || role === "tank";
    }

    function isHealer(c){
      const cls = String(c?.class || "").toLowerCase();
      const role = String(c?.role || "").toLowerCase();
      return cls === "healer" || role === "healer";
    }

    function passesTankHealerCap(party, charsById){
      let tank = 0, healer = 0;
      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) continue;
        if (isTank(c)) tank++;
        if (isHealer(c)) healer++;
        if (tank > 1 || healer > 1) return false;
      }
      return true;
    }

    function passesRequiredClasses(party, charsById, requiredClassSet){
      if (!requiredClassSet || requiredClassSet.size === 0) return true;

      const seen = new Set();
      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) continue;
        seen.add(String(c.class || "-"));
      }

      for (const req of requiredClassSet){
        if (!seen.has(req)) return false;
      }
      return true;
    }

    function partyScore(party, rankMap, charsById){
      let sum = 0;
      const elem = new Map();
      const fac = new Map();

      for (const cid of party){
        const c = charsById.get(cid);

        // tier 점수
        sum += (rankMap.get(cid) || 0) * 100;

        // rarity 보너스(동명이인 충돌 상황에서 SSR 우선 선택 유도)
        sum += rarityVal(c?.rarity) * 5;

        if (!c) continue;
        const e = c.element || "-";
        const f = c.faction || "-";
        elem.set(e, (elem.get(e) || 0) + 1);
        fac.set(f, (fac.get(f) || 0) + 1);
      }

      const maxElem = Math.max(0, ...elem.values());
      const maxFac = Math.max(0, ...fac.values());

      if (maxElem >= 2) sum += 20;
      if (maxFac >= 2) sum += 20;
      if (maxElem >= 3) sum += 10;
      if (maxFac >= 3) sum += 10;

      return sum;
    }

    function tierLabelFromScore(s){
      if (s === 4) return "SSS";
      if (s === 3) return "SS";
      if (s === 2) return "S";
      if (s === 1) return "A";
      return "-";
    }

    /**
     * ✅ 한 번에 "최고 1개 파티"를 뽑는다(현재 남아있는 후보 중)
     * - usedSet(카테고리 내부 중복 금지)을 반영해 후보에서 제외
     * - 조건 만족하는 4인 조합 중 점수 최고 선택
     */
    function buildBestPartyOnce(rankMap, usedSet, forcedIds, reservedAll){
  const owned = getOwnedSelectedIds();
  if (owned.length < 4) return { ok:false, msg:"보유 체크가 4명 이상이어야 합니다." };

  const charsById = new Map(chars.map(c => [c.id, c]));

  // 강제 포함(필수) 정리
  const forced = (Array.isArray(forcedIds) ? forcedIds : [])
    .filter(cid => cid && charsById.has(cid))
    .filter((cid, i, arr) => arr.indexOf(cid) === i)
    .filter(cid => owned.includes(cid))
    .filter(cid => !usedSet.has(cid)); // 이미 같은 카테고리에서 사용된 캐릭터는 불가

  if (forced.length > 4){
    return { ok:false, msg:"필수 지정이 4명을 초과했습니다." };
  }

  const reserved = new Set();
  if (reservedAll instanceof Set){
    for (const cid of reservedAll) reserved.add(cid);
  }
  // 다른 파티에 지정된 필수 캐릭터를 미리 소비하지 않도록, (reserved - forced)는 후보에서 제외
  for (const cid of forced) reserved.delete(cid);

  // usedSet(카테고리 중복 금지) + reserved(다른 파티 필수 보호) 제외
  const candidatesAll = owned
    .filter(cid => charsById.has(cid))
    .filter(cid => !usedSet.has(cid))
    .filter(cid => !reserved.has(cid) || forced.includes(cid));

  // 강제 포함이 있는 경우에도, 최소한 남은 자리가 채워질 후보가 있어야 함
  const need = 4 - forced.length;
  const rest = candidatesAll.filter(cid => !forced.includes(cid));
  if (rest.length < need){
    return { ok:false, msg:"(필수/중복 제외 후) 후보가 부족하여 파티를 구성할 수 없습니다." };
  }

  const classSet = getEnabledClassSet();
  if (classSet && classSet.size > 4){
    return { ok:false, msg:"선택 클래스는 최대 4개까지만 지정할 수 있습니다(4인 파티)." };
  }

  // tier 우선 정렬(없으면 0)
  const sorted = candidatesAll.slice().sort((a,b) => (rankMap.get(b) || 0) - (rankMap.get(a) || 0));

  // 탐색 풀 제한(브라우저 성능 보호)
  const N = Math.min(28, sorted.length);

  // forced는 무조건 풀에 포함, 나머지 상위 N에서 채움
  const pool = [];
  for (const cid of forced) pool.push(cid);
  for (const cid of sorted){
    if (pool.length >= N) break;
    if (pool.includes(cid)) continue;
    pool.push(cid);
  }

  const poolRest = pool.filter(cid => !forced.includes(cid));
  const m = forced.length;

  // 조합 탐색(강제 포함을 고정한 상태로 나머지 자리만 탐색)
  let best = null;

  function consider(party){
    if (!passesTankHealerCap(party, charsById)) return;
    if (!passesRequiredClasses(party, charsById, classSet)) return;

    if (!hasComboSkill(party, charsById)) return;
    if (!allMembersContributeToCombo(party, charsById)) return;

    const sc = partyScore(party, rankMap, charsById);
    if (!best || sc.score > best.score){
      best = { party, score: sc.score, details: sc.details };
    }
  }

  if (m === 4){
    consider(forced.slice(0,4));
  } else if (m === 3){
    for (let i=0; i<poolRest.length; i++){
      consider([forced[0], forced[1], forced[2], poolRest[i]]);
    }
  } else if (m === 2){
    for (let i=0; i<poolRest.length-1; i++){
      for (let j=i+1; j<poolRest.length; j++){
        consider([forced[0], forced[1], poolRest[i], poolRest[j]]);
      }
    }
  } else if (m === 1){
    for (let i=0; i<poolRest.length-2; i++){
      for (let j=i+1; j<poolRest.length-1; j++){
        for (let k=j+1; k<poolRest.length; k++){
          consider([forced[0], poolRest[i], poolRest[j], poolRest[k]]);
        }
      }
    }
  } else {
    // 기존: 4-combination
    for (let i=0; i<poolRest.length-3; i++){
      for (let j=i+1; j<poolRest.length-2; j++){
        for (let k=j+1; k<poolRest.length-1; k++){
          for (let l=k+1; l<poolRest.length; l++){
            consider([poolRest[i], poolRest[j], poolRest[k], poolRest[l]]);
          }
        }
      }
    }
  }

  if (!best){
    return { ok:false, msg:"조건(탱/힐 제한/콤보) 때문에 파티 구성이 불가합니다. 후보를 늘리거나 클래스 포함 조건을 완화하세요." };
  }

  return { ok:true, party: best.party, score: best.score, scoreDetails: best.details };
}

    /**
 * ✅ 카테고리별로 n개 파티 만들기(카테고리 내부 중복 금지)
 * - mustByParty: [ [cid...], [cid...], ... ] (각 파티별 강제 포함)
 * - 같은 카테고리 내 파티끼리 중복은 금지(usedSet)
 * - 다른 파티에 "지정된 필수" 캐릭터를 먼저 소비하지 않도록 예약(reservedAll) 반영
 */
function buildPartiesForCategory(rankMap, n, mustByParty){
  const used = new Set();
  const parties = [];

  const mustLists = Array.isArray(mustByParty) ? mustByParty : [];
  const reservedAll = new Set();
  for (const arr of mustLists){
    if (!Array.isArray(arr)) continue;
    for (const cid of arr) reservedAll.add(cid);
  }

  for (let i=0; i<n; i++){
    const forced = Array.isArray(mustLists[i]) ? mustLists[i] : [];
    const res = buildBestPartyOnce(rankMap, used, forced, reservedAll);
    if (!res.ok) break;

    parties.push(res.party);
    for (const cid of res.party) used.add(cid);
  }

  return parties;
}

// ------------------------------
// Multi-party build optimization
// ------------------------------
// buildPartiesForCategory()는 파티를 1→N 순서로 그리디하게 구성합니다.
// 다파티(특히 Guild/PVP/Rift)에서는 "어느 파티를 먼저 채우느냐"가 결과에 영향을 주므로,
// n이 작을 때(<=3) 모든 순열을 시도하여 총점 합이 최대가 되는 순서를 선택합니다.

function _permute(arr){
  const out = [];
  function rec(prefix, rest){
    if (!rest.length){ out.push(prefix.slice()); return; }
    for (let i=0; i<rest.length; i++){
      const next = rest[i];
      const r2 = rest.slice(0,i).concat(rest.slice(i+1));
      prefix.push(next);
      rec(prefix, r2);
      prefix.pop();
    }
  }
  rec([], arr.slice());
  return out;
}

function buildPartiesForCategoryWithOrder(rankMap, n, mustByParty, order){
  const used = new Set();
  const parties = new Array(n).fill(null);

  const mustLists = Array.isArray(mustByParty) ? mustByParty : [];
  const reservedAll = new Set();
  for (const arr of mustLists){
    if (!Array.isArray(arr)) continue;
    for (const cid of arr) reservedAll.add(cid);
  }

  const ord = Array.isArray(order) && order.length === n
    ? order
    : [...Array(n).keys()];

  for (const idx of ord){
    const forced = Array.isArray(mustLists[idx]) ? mustLists[idx] : [];
    const res = buildBestPartyOnce(rankMap, used, forced, reservedAll);
    if (!res.ok) return { ok:false, msg: res.msg || "파티 구성 실패", parties: [] };
    parties[idx] = res;
    // 중복 금지 소비
    for (const cid of res.party) used.add(cid);
  }

  return { ok:true, parties };
}

function buildPartiesForCategoryOptimized(rankMap, n, mustByParty){
  // n이 작을 때만 순열 최적화(요청사항: Guild 3, PVP 2, Left 2)
  const nn = Math.max(0, Number(n||0)|0);
  if (nn <= 1){
    const p = buildPartiesForCategory(rankMap, nn, mustByParty);
    return p;
  }

  const idxs = [...Array(nn).keys()];
  const perms = _permute(idxs);

  let best = null;
  for (const ord of perms){
    const res = buildPartiesForCategoryWithOrder(rankMap, nn, mustByParty, ord);
    if (!res.ok) continue;
    const sum = res.parties.reduce((a,x)=>a + (x?.score||0), 0);
    if (!best || sum > best.sum){
      best = { sum, parties: res.parties, order: ord };
    }
  }

  if (!best){
    // 기존 로직 fallback
    return buildPartiesForCategory(rankMap, nn, mustByParty);
  }

  // buildPartiesForCategory()가 반환하는 형식과 동일하게 배열로 리턴
  return best.parties;
}

/**
 * ✅ 기본 파티 수(요청사항)
 * - Guild 3
 * - PVP 2
 * - Rift 2
 * - 나머지 1
 */
const PARTY_COUNTS = { Guild:3, PVE:1, PVP:2, Rift:2 };

function buildEmptyMustMap(){
  return {
    Guild: Array.from({length: PARTY_COUNTS.Guild}, () => []),
    PVP:   Array.from({length: PARTY_COUNTS.PVP},   () => []),
    Rift:  Array.from({length: PARTY_COUNTS.Rift},  () => []),
    PVE:   Array.from({length: PARTY_COUNTS.PVE},   () => []),
  };
}


// autoMust(타겟 미지정)는 "현재 빌드 대상"의 첫 카테고리에 자동 배치합니다.
// 기존 라운드로빈은 '모두 1파티' 문제를 완화하지만, 최적이 아닙니다.
// ✅ 개선: 각 autoMust를 어느 파티에 넣을지 '총점 합 최대'가 되도록 자동 판단(점수 최적화).
function applyAutoMust(autoMust, mustByCat, primaryCat, rankMap){
  const list = (Array.isArray(autoMust) ? autoMust : []).slice().filter(Boolean);
  if (!list.length) return;

  const cat = String(primaryCat||"");
  const arr = mustByCat[cat];
  if (!Array.isArray(arr) || !arr.length) return;

  const n = arr.length;

  // 이미 특정 파티에 강제 지정된 필수는 건드리지 않음
  const already = new Set();
  for (const p of arr){
    for (const cid of (p||[])) already.add(cid);
  }

  // autoMust 중복 제거 + 이미 지정된 항목 제거
  const uniq = [];
  const seen = new Set();
  for (const cid of list){
    if (already.has(cid)) continue;
    if (seen.has(cid)) continue;
    seen.add(cid);
    uniq.push(cid);
  }
  if (!uniq.length) return;

  // 그리디 최적화: 하나씩 넣어보며 "총점 합"이 가장 커지는 파티에 배치
  // (n<=3이므로 buildPartiesForCategoryOptimized를 여러 번 호출해도 충분히 감당 가능)
  for (const cid of uniq){
    let bestIdx = -1;
    let bestSum = -Infinity;

    for (let i=0; i<n; i++){
      if ((arr[i]||[]).length >= 4) continue;

      // 시뮬레이션용 mustByParty 복제
      const tmp = arr.map(x => (Array.isArray(x) ? x.slice() : []));
      tmp[i].push(cid);

      const parties = buildPartiesForCategoryOptimized(rankMap, n, tmp);
      if (!Array.isArray(parties) || parties.length < n) continue;

      // 모든 파티가 정상 구성된 경우만 평가
      let ok = true;
      let sum = 0;
      for (const p of parties){
        if (!p || p.ok === false || !Array.isArray(p.party)) { ok = false; break; }
        sum += (p.score || 0);
      }
      if (!ok) continue;

      if (sum > bestSum){
        bestSum = sum;
        bestIdx = i;
      }
    }

    if (bestIdx >= 0){
      arr[bestIdx].push(cid);
    } else {
      // 넣을 곳이 없거나(4명 초과) 조건 때문에 실패 → 마지막에 sanitize가 경고를 찍도록 둠
      // (여기서는 조용히 스킵)
    }
  }
}

function sanitizeMustByCat(mustByCat){
  // 1) 파티 내 중복 제거
  // 2) 같은 카테고리 내, 여러 파티에 중복 지정된 cid는 "먼저 나온 것"만 유지
  const warnings = [];
  for (const cat of Object.keys(mustByCat)){
    const arr = mustByCat[cat];
    if (!Array.isArray(arr)) continue;

    // 파티 내 중복 제거
    for (let i=0; i<arr.length; i++){
      const seen = new Set();
      arr[i] = (arr[i] || []).filter(cid => {
        if (seen.has(cid)) return false;
        seen.add(cid);
        return true;
      });
    }

    // 파티 간 중복 제거
    const used = new Set();
    for (let i=0; i<arr.length; i++){
      const before = arr[i].slice();
      arr[i] = arr[i].filter(cid => {
        if (used.has(cid)) return false;
        used.add(cid);
        return true;
      });
      if (arr[i].length !== before.length){
        warnings.push(`${cat}: 필수 캐릭터가 여러 파티에 중복 지정되어 일부는 첫 파티 배치만 유지했습니다.`);
      }
    }

    // 4명 초과는 뒤로 넘기되, 넘길 곳이 없으면 경고
    for (let i=0; i<arr.length; i++){
      while (arr[i].length > 4){
        const moved = arr[i].pop();
        let j = i+1;
        while (j < arr.length && arr[j].length >= 4) j++;
        if (j < arr.length) arr[j].push(moved);
        else {
          warnings.push(`${cat}: 필수 지정이 4명을 초과하여 일부는 반영되지 않을 수 있습니다.`);
          break;
        }
      }
    }
  }
  return { mustByCat, warnings };
}

function buildAllCategoryParties(rankMap, mustByCat){
  const must = mustByCat || buildEmptyMustMap();
  return {
    Guild: buildPartiesForCategoryOptimized(rankMap, PARTY_COUNTS.Guild, must.Guild),
    PVE:   buildPartiesForCategoryOptimized(rankMap, PARTY_COUNTS.PVE,   must.PVE),
    PVP:   buildPartiesForCategoryOptimized(rankMap, PARTY_COUNTS.PVP,   must.PVP),
    Rift:  buildPartiesForCategoryOptimized(rankMap, PARTY_COUNTS.Rift,  must.Rift),
  };
}

// ✅ 선택한 등급표(pve/pvp/left/guild-raid/...)에 맞춰 결과 카테고리를 제한
function buildPartiesByPresetKey(rankMap, presetKey){
  const k = String(presetKey || "").toLowerCase();

  const mustRaw = getMustAssignments();
  const mustByCat = buildEmptyMustMap();

  // explicit 배치 반영
  if (mustRaw && mustRaw.byCategory){
    for (const cat of ["Guild", "PVP", "Rift", "PVE"]){
      const src = mustRaw.byCategory[cat];
      if (!Array.isArray(src)) continue;
      for (let i=0; i<mustByCat[cat].length; i++){
        mustByCat[cat][i] = (src[i] || []).slice();
      }
    }
  }

  // 기본값: 전체 카테고리
  const defOrder = ["Guild", "PVE", "PVP", "Rift"];
  const primaryCat = (
    k === "pvp" ? "PVP" :
    (k === "rift" || k === "left") ? "Rift" :
    (k === "guild-raid" ? "Guild" :
     (k === "pve" || k === "new-player") ? "PVE" :
     "Guild")
  );

  // auto must를 primaryCat에 라운드로빈 분배
  applyAutoMust(mustRaw?.auto || [], mustByCat, primaryCat, rankMap);

  const sanitized = sanitizeMustByCat(mustByCat);

  if (k === "pvp") {
    return {
      order: ["PVP"],
      data: { PVP: buildPartiesForCategory(rankMap, PARTY_COUNTS.PVP, sanitized.mustByCat.PVP) },
      warnings: sanitized.warnings
    };
  }
  if (k === "pve" || k === "new-player") {
    return {
      order: ["PVE"],
      data: { PVE: buildPartiesForCategory(rankMap, PARTY_COUNTS.PVE, sanitized.mustByCat.PVE) },
      warnings: sanitized.warnings
    };
  }
  if (k === "rift" || k === "left") {
    return {
      order: ["Rift"],
      data: { Rift: buildPartiesForCategory(rankMap, PARTY_COUNTS.Rift, sanitized.mustByCat.Rift) },
      warnings: sanitized.warnings
    };
  }
  if (k === "guild-raid") {
    return {
      order: ["Guild"],
      data: { Guild: buildPartiesForCategory(rankMap, PARTY_COUNTS.Guild, sanitized.mustByCat.Guild) },
      warnings: sanitized.warnings
    };
  }

  return {
    order: defOrder,
    data: buildAllCategoryParties(rankMap, sanitized.mustByCat),
    warnings: sanitized.warnings
  };
}
function renderTierPartyResult(rankMap, res){
      const box = document.getElementById("tierPartyResult");
      if (!box) return;

      let warnHtml = "";
      if (res.warnings && res.warnings.length){
        warnHtml = `<div class="tier-warn">${res.warnings.map(w=>`<div>• ${escapeHtml(w)}</div>`).join("")}</div>`;
      }

      if (!res.ok){
        box.innerHTML = warnHtml + `<div class="tier-error">${escapeHtml(res.msg || "실패")}</div>`;
        return;
      }

      const charsById = new Map(chars.map(c => [c.id, c]));

      const renderOneParty = (party) => {
        const cards = party.map(cid => {
          const c = charsById.get(cid);

          const img = c?.image
            ? `<img class="tier-portrait" src="${escapeHtml(c.image)}" alt="">`
            : `<div class="tier-portrait tier-portrait-empty"></div>`;

          return `
            <div class="tier-card">
              <div class="tier-card-top">
                ${img}
                <span class="tier-name">${escapeHtml(c?.name || cid)}</span>
              </div>
              <div class="tier-card-sub">
                <span class="pill pill-neutral">${escapeHtml(c?.element || "-")}</span>
                <span class="pill pill-neutral">${escapeHtml(c?.faction || "-")}</span>
                <span class="pill pill-neutral">${escapeHtml(c?.class || "-")}</span>
              </div>
            </div>
          `;
        }).join("");

        return `<div class="tier-grid">${cards}</div>`;
      };

      const sections = res.data;
      const order = Array.isArray(res.order) && res.order.length
        ? res.order
        : ["Guild", "PVE", "PVP", "Rift"];

      const html = order.map(cat => {
        const parties = sections[cat] || [];
        if (!parties.length){
          return `
            <div class="tier-section">
              <div class="tier-section-head">
                <div class="tier-section-title">${escapeHtml(cat)}</div>
              </div>
              <div class="tier-error" style="margin-top:8px;">${escapeHtml(cat)}: 조건을 만족하는 파티를 구성하지 못했습니다(후보 부족/조건 과다).</div>
            </div>
          `;
        }

        return `
          <div class="tier-section">
            <div class="tier-section-head">
              <div class="tier-section-title">${escapeHtml(cat)}</div>
              <div class="tier-section-sub">총 ${parties.length}개</div>
            </div>
            ${parties.map((p, idx) => `
              <div class="tier-party-block">
                <div class="tier-party-title">${escapeHtml(cat)} ${idx + 1}</div>
                ${renderOneParty(p)}
              </div>
            `).join("")}
          </div>
        `;
      }).join("");

      box.innerHTML = warnHtml + html;
    }

    function initTierUI(){
      const sel = document.getElementById("tierPreset");
      const btn = document.getElementById("btnBuildTierParty");
      const btnAi = document.getElementById("btnAiParty");
      // ✅ 요청사항: 구성조건/lastUpdated 안내 영역 제거(없어도 동작)
      const info = document.getElementById("tierInfo"); // (없을 수 있음)
      const help = document.getElementById("tierHelp"); // (없을 수 있음)
      if (!sel || !btn || !btnAi) return;
      if (!ALL_TIER_LISTS) return;

      const keys = Object.keys(ALL_TIER_LISTS).sort((a,b) => a.localeCompare(b));

      sel.innerHTML = `<option value="">등급표 선택</option>` + keys.map(k => {
        const t = ALL_TIER_LISTS[k];
        const nm = String(t?.name || k).trim();
        return `<option value="${escapeHtml(k)}">${escapeHtml(nm)}</option>`;
      }).join("");

      sel.disabled = false;
      btn.disabled = false;
      btnAi.disabled = false;

      initTierClassCheckboxes();

      function renderInfo(k){
        // ✅ 요청사항: 구성조건/lastUpdated 등의 안내 문구는 표시하지 않음
        if (info) info.textContent = "";
        if (help) help.innerHTML = "";
      }

      sel.addEventListener("change", () => {
        renderInfo(sel.value);
        document.getElementById("tierPartyResult").innerHTML = "";
        document.getElementById("aiPartyResult").innerHTML = "";
      });

      btn.addEventListener("click", () => {
        const k = sel.value;
        if (!k) {
          renderTierPartyResult(new Map(), { ok:false, msg:"등급표를 먼저 선택하세요." });
          return;
        }
        const tierList = ALL_TIER_LISTS[k];
        const rankMap = buildRankMapFromTierList(tierList, chars);

        const built = buildPartiesByPresetKey(rankMap, k);
        renderTierPartyResult(rankMap, { ok:true, ...built });
      });

      btnAi.addEventListener("click", () => {
        requestAiParty();
      });

      renderInfo(sel.value);
    }

    
    // ✅ 초기 캐릭터 목록 렌더 (필수)
    // - render()가 호출되지 않으면 tbody가 비어 보입니다.
    try { render().catch(console.error); } catch(e) { console.error(e); }

// ===== Tier (details) collapse: 검색/필터와 동일한 (열기/닫기) UX =====
    // - 모바일에서는 기본 접힘
    // - 사용자가 한 번 열고/닫으면 localStorage로 기억
    (function initTierDetailsCollapse(){
      const d = document.getElementById("tierPanel");
      if (!d) return;

      const KEY = "tierPanelOpen";
      const mq = window.matchMedia("(max-width: 520px)");

      const applyDefault = () => {
        if (mq.matches) d.removeAttribute("open");
        else d.setAttribute("open", "");
      };

      const saved = localStorage.getItem(KEY);
      if (saved === "1") d.setAttribute("open", "");
      else if (saved === "0") d.removeAttribute("open");
      else applyDefault();

      d.addEventListener("toggle", () => {
        localStorage.setItem(KEY, d.open ? "1" : "0");
      });

      mq.addEventListener?.("change", () => {
        if (localStorage.getItem(KEY) == null) applyDefault();
      });
    })();

    window.addEventListener("tierlists:loaded", () => {
      ALL_TIER_LISTS = window.__tierLists?.ALL_TIER_LISTS || null;

      if (!ALL_TIER_LISTS) {
        const sel = document.getElementById("tierPreset");
        const info = document.getElementById("tierInfo");
        if (sel) {
          sel.innerHTML = `<option value="">등급표 로딩 실패</option>`;
          sel.disabled = true;
        }
        if (info) {
          info.textContent = "tier-lists.js(tier-list.js) 모듈을 불러오지 못했습니다. 경로/파일명을 확인하세요.";
        }
        return;
      }

      initTierUI();
    });
  </script>

  
  <!-- ✅ rune set meta loader (set effect text for 추천 룬) -->
  <script type="module">
    const candidates = [
      "/data/zone-nova/runes.js",
      "/data/zone-nova/rune-sets.js",
      "/data/zone-nova/runesets.js",
      "/data/zone-nova/runes_ko.js",
      "/data/zone-nova/runes_ko.json",
      "/data/zone-nova/runes.json"
    ];

    let loaded = null;

    for (const p of candidates) {
      try {
        if (p.endsWith(".json")) {
          const r = await fetch(p, { cache: "no-store" });
          if (!r.ok) continue;
          loaded = await r.json();
        } else {
          loaded = await import(p);
        }
        if (loaded) break;
      } catch (e) {}
    }

    try {
      if (loaded && typeof window.normalizeRuneSetMeta === "function" && typeof window.setRuneSetMeta === "function") {
        const meta = window.normalizeRuneSetMeta(loaded);
        window.setRuneSetMeta(meta);
      } else {
        window.dispatchEvent(new Event("runesmeta:loaded"));
      }
    } catch (e) {
      window.dispatchEvent(new Event("runesmeta:loaded"));
    }
  </script>

<!-- ✅ tier-lists 모듈 import (파일명 혼동 대비 fallback) -->
  <script type="module">
    const candidates = [
      "/data/zone-nova/tier-lists.js",
      "/data/zone-nova/tier-list.js"
    ];

    let mod = null;
    for (const p of candidates) {
      try {
        mod = await import(p);
        window.__tierLists = mod;
        window.__tierListsPath = p;
        break;
      } catch (e) {}
    }

    window.dispatchEvent(new Event("tierlists:loaded"));
  </script>

</body>
</html>
