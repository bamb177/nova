<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>{{ title }}</title>

  <link rel="stylesheet" href="/css/style.css" />
  <link rel="stylesheet" href="/css/select.css" />
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>{{ title }}</h1>
        <div class="meta">
          캐릭터 {{ cache_count }}명 · 갱신 {{ last_refresh }}
        </div>
      </div>
      <div class="actions">
        <a class="btn" href="/refresh">새로고침</a>
        <div class="badge">데이터: <span id="sourceHint">-</span></div>
      </div>
    </div>

    {% if error %}
      <div class="error">로딩 오류: {{ error }}</div>
    {% endif %}

    <div class="panel">
      <div class="filters">
        <!-- ===== Tier Party Builder ===== -->
      <div class="tier-panel">
        <div class="tier-row">
          <label class="tier-label">등급표</label>
          <select id="tierPreset" class="select" disabled>
            <option value="">tier-lists.js 로딩중...</option>
          </select>
      
          <button class="btn" id="btnBuildTierParty" type="button" disabled>등급표로 파티 구성</button>
        </div>
      
        <div class="tier-row">
          <label class="tier-check">
            <input type="checkbox" id="useClassFilter" />
            클래스 필터 사용
          </label>
      
          <div class="tier-classes" id="tierClassBox" aria-disabled="true"></div>
        </div>
      
        <div class="tier-help">
          조건: 보유 체크된 캐릭터 중 4인 구성 / SSS→SS→S→A 우선 /
          콤보 스킬(속성 2+ 또는 특성 2+) 필수
        </div>
      
        <div id="tierPartyResult" class="tier-result"></div>
      </div>

        <input id="q" class="input" type="text" placeholder="검색 (이름/ID/특성/속성)" autocomplete="off" />
        <select id="rarityFilter" class="select">
          <option value="">등급(전체)</option>
          <option value="SSR">SSR</option>
          <option value="SR">SR</option>
        </select>
        <select id="elemFilter" class="select">
          <option value="">속성(전체)</option>
        </select>
        <select id="factionFilter" class="select">
          <option value="">특성(전체)</option>
        </select>
        <select id="classFilter" class="select">
          <option value="">클래스(전체)</option>
        </select>
        <select id="roleFilter" class="select">
          <option value="">역할(전체)</option>
        </select>

        <button class="btn" id="btnAll" type="button">전체 선택</button>
        <button class="btn" id="btnNone" type="button">전체 해제</button>
      </div>

      <!-- ✅ 모바일 가로 터치 스크롤을 위한 래퍼 -->
      <div class="table-wrap">
        <table class="table">
          <thead>
            <tr>
              <th class="col-check">선택</th>
              <th>캐릭터</th>
              <th class="col-elem">속성</th>
              <th class="col-faction">특성</th>
              <th class="col-class">클래스</th>
              <th class="col-role">역할</th>
              <th class="col-rarity">등급</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- ===== Modal ===== -->
  <div class="modal-backdrop" id="modalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modal-head">
        <div class="modal-title" id="modalTitle">Character</div>
        <button class="modal-close" id="modalClose" type="button">×</button>
      </div>
      <div class="modal-body" id="modalBody">
        <div class="modal-loading">Loading…</div>
      </div>
    </div>
  </div>

  <script>
    const CHARS_RAW = {{ chars_json|safe }};

    function escapeHtml(str) {
      return (str || "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }

    function dedupeById(list){
      const m = new Map();
      for (const c of (list || [])){
        if (!c) continue;
        const id = (c.id || "").toString().trim();
        if (!id) continue;
        if (!m.has(id)) m.set(id, c);
      }
      return Array.from(m.values());
    }

    const RARITY_ORDER = { "SSR": 3, "SR": 2, "R": 1, "-": 0 };

    function classLabel(cls){
      const v = (cls || "-").toString().trim();
      return v || "-";
    }

    function roleLabel(role){
      const v = (role || "-").toString().trim();
      return v || "-";
    }

    function rarityPillClass(r){
      const v = (r || "-").toString().trim().toUpperCase();
      if (v === "SSR") return "pill-ssr";
      if (v === "SR") return "pill-sr";
      if (v === "R") return "pill-r";
      return "pill-none";
    }

    // ===== detail helpers =====
    function pick(obj, ...keys) {
      for (const k of keys) {
        const v = obj?.[k];
        if (v !== undefined && v !== null) return v;
      }
      return null;
    }

    function isEmpty(v) {
      if (v === null || v === undefined) return true;
      if (Array.isArray(v)) return v.length === 0;
      if (typeof v === "object") return Object.keys(v).length === 0;
      if (typeof v === "string") return v.trim() === "";
      return false;
    }

    function renderKV(obj) {
      if (!obj || typeof obj !== "object") return `<div class="detail-empty">데이터 없음</div>`;
      const rows = Object.entries(obj).map(([k, v]) => {
        const vv = (typeof v === "object") ? JSON.stringify(v) : String(v);
        return `<tr><td class="kv-k">${escapeHtml(k)}</td><td class="kv-v">${escapeHtml(vv)}</td></tr>`;
      }).join("");
      return `<table class="kv"><tbody>${rows}</tbody></table>`;
    }

    function looksLikeSkillObject(o){
      if (!o || typeof o !== "object" || Array.isArray(o)) return false;
      const keys = ["name","title","skillName","description","desc","text","cooldown","energyCost","cost","type","category"];
      return keys.some(k => o[k] !== undefined && o[k] !== null);
    }

    function normalizeSkillEntry(x, fallbackTitle) {
      if (!x) return { title: fallbackTitle || "-", desc: "", extra: null };

      if (typeof x === "string") {
        return { title: fallbackTitle || "-", desc: x, extra: null };
      }

      if (typeof x === "object") {
        const title =
          (typeof x.name === "string" && x.name) ||
          (typeof x.title === "string" && x.title) ||
          (typeof x.skillName === "string" && x.skillName) ||
          fallbackTitle || "-";

        const desc =
          (typeof x.description === "string" && x.description) ||
          (typeof x.desc === "string" && x.desc) ||
          (typeof x.text === "string" && x.text) ||
          "";

        const extra = {};
        for (const [k, v] of Object.entries(x)) {
          if (["name","title","skillName","description","desc","text"].includes(k)) continue;
          if (v === null || v === undefined) continue;
          if (typeof v === "object") continue;
          extra[k] = v;
        }
        return { title, desc, extra: Object.keys(extra).length ? extra : null };
      }

      return { title: fallbackTitle || "-", desc: String(x), extra: null };
    }

    function renderOneSkillCard(s) {
      const desc = s.desc
        ? `<div class="card-desc">${escapeHtml(s.desc)}</div>`
        : `<div class="card-desc" style="opacity:.75;">(설명 없음)</div>`;
      const extra = s.extra ? renderKV(s.extra) : "";
      return `
        <div class="card">
          <div class="card-title"><span>${escapeHtml(String(s.title || "-"))}</span></div>
          ${desc}
          ${extra ? `<div style="margin-top:8px;">${extra}</div>` : ""}
        </div>
      `;
    }

    function renderSkillCards(skillsObjOrArr) {
      if (isEmpty(skillsObjOrArr)) return `<div class="detail-empty">스킬 데이터 없음</div>`;

      if (looksLikeSkillObject(skillsObjOrArr)) {
        const s = normalizeSkillEntry(skillsObjOrArr, "Skill");
        return `<div class="cards">${renderOneSkillCard(s)}</div>`;
      }

      if (Array.isArray(skillsObjOrArr)) {
        const cards = skillsObjOrArr
          .map((x, idx) => renderOneSkillCard(normalizeSkillEntry(x, `Skill ${idx + 1}`)))
          .join("");
        return `<div class="cards">${cards}</div>`;
      }

      if (typeof skillsObjOrArr === "object") {
        const cards = [];
        for (const [k, v] of Object.entries(skillsObjOrArr)) {
          if (isEmpty(v)) continue;

          if (looksLikeSkillObject(v)) {
            cards.push(renderOneSkillCard(normalizeSkillEntry(v, k)));
            continue;
          }

          if (Array.isArray(v)) {
            for (let i = 0; i < v.length; i++) {
              cards.push(renderOneSkillCard(normalizeSkillEntry(v[i], `${k} ${i + 1}`)));
            }
          }
        }

        if (cards.length === 0) {
          const s = normalizeSkillEntry(skillsObjOrArr, "Skill");
          return `<div class="cards">${renderOneSkillCard(s)}</div>`;
        }
        return `<div class="cards">${cards.join("")}</div>`;
      }

      const s = normalizeSkillEntry(skillsObjOrArr, "Skill");
      return `<div class="cards">${renderOneSkillCard(s)}</div>`;
    }

    // Auto/Ultimate/Passive/Normal/Team Skill 고정 + 색상 구분(class)
    function renderSkills(detail) {
      const skills = pick(detail, "skills") || {};
      const teamSkill = pick(detail, "teamSkill", "team_skill", "team");

      const normalData = !isEmpty(skills?.normal) ? skills.normal : skills?.basic;

      const sections = [
        { label: "Auto",       data: skills?.auto,     css: "group-auto" },
        { label: "Ultimate",   data: skills?.ultimate, css: "group-ultimate" },
        { label: "Passive",    data: skills?.passive,  css: "group-passive" },
        { label: "Normal",     data: normalData,       css: "group-normal" },
        { label: "Team Skill", data: teamSkill,        css: "group-team" },
      ];

      return sections.map(s => `
        <div class="group ${s.css}">
          <div class="group-title">${escapeHtml(s.label)}</div>
          ${isEmpty(s.data) ? `<div class="detail-empty">${escapeHtml(s.label)} 데이터 없음</div>` : renderSkillCards(s.data)}
        </div>
      `).join("");
    }

    function normalizeAwakenings(aw) {
      if (!aw) return [];
      if (Array.isArray(aw)) return aw;
      if (typeof aw === "object") {
        if (Array.isArray(aw.levels)) return aw.levels;
      }
      return [];
    }

    function awakenRowEffect(x) {
      if (x == null) return "";
      if (typeof x === "string") return x;
      if (typeof x === "number" || typeof x === "boolean") return String(x);
      if (typeof x === "object") {
        const eff = pick(x, "effect", "effects", "desc", "description", "text");
        if (typeof eff === "string") return eff;
        return JSON.stringify(x, null, 2);
      }
      return String(x);
    }

    function renderAwakenings(detail) {
      const aw = pick(detail, "awakenings", "awakening");
      const rows = normalizeAwakenings(aw);

      if (!rows.length) return `<div class="detail-empty">각성 데이터 없음</div>`;

      const tbody = rows.map((x, idx) => {
        const lvl = pick(x, "level", "lv", "stage") ?? (idx + 1);
        const eff = awakenRowEffect(x);
        return `<tr><td style="width:110px;font-weight:950;">Lv.${escapeHtml(String(lvl))}</td><td>${escapeHtml(eff)}</td></tr>`;
      }).join("");

      return `
        <table class="awak-table">
          <thead><tr><th style="width:110px;">레벨</th><th>효과</th></tr></thead>
          <tbody>${tbody}</tbody>
        </table>
      `;
    }

    function renderMemoryCard(detail) {
      const mem = pick(detail, "memoryCard", "memory_card");
      if (isEmpty(mem)) return `<div class="detail-empty">메모리카드 데이터 없음</div>`;

      if (typeof mem !== "object") {
        return `<div class="detail-empty">${escapeHtml(String(mem))}</div>`;
      }

      const name = pick(mem, "name", "title") || "Memory Card";
      const desc = pick(mem, "description", "desc", "text") || "";
      const effects = pick(mem, "effects", "effect");

      let effectsHtml = "";
      if (Array.isArray(effects)) {
        effectsHtml = `
          <table class="awak-table">
            <thead><tr><th style="width:110px;">순번</th><th>효과</th></tr></thead>
            <tbody>
              ${effects.map((e, i) => `<tr><td style="font-weight:950;">${i+1}</td><td>${escapeHtml(typeof e === "string" ? e : JSON.stringify(e, null, 2))}</td></tr>`).join("")}
            </tbody>
          </table>
        `;
      } else if (effects && typeof effects === "object") {
        effectsHtml = renderKV(effects);
      } else if (typeof effects === "string") {
        effectsHtml = `<div class="card-desc">${escapeHtml(effects)}</div>`;
      } else {
        effectsHtml = renderKV(mem);
      }

      return `
        <div class="card">
          <div class="card-title"><span>${escapeHtml(String(name))}</span></div>
          ${desc ? `<div class="card-desc">${escapeHtml(String(desc))}</div>` : ""}
          <div style="margin-top:10px;">${effectsHtml}</div>
        </div>
      `;
    }

    function renderPanel(id, html, active=false) {
      return `<div class="tab-panel ${active ? "active" : ""}" data-panel="${escapeHtml(id)}">${html}</div>`;
    }

    function renderDetailTabs(detail) {
      const tabs = [
        { id: "skills", label: "스킬", content: renderSkills(detail) },
        { id: "awakenings", label: "각성", content: renderAwakenings(detail) },
        { id: "memory", label: "메모리카드", content: renderMemoryCard(detail) },
      ];
      const firstActive = "skills";

      const tabBtns = tabs.map(t =>
        `<button type="button" class="tab-btn ${t.id === firstActive ? "active" : ""}" data-tab="${escapeHtml(t.id)}">${escapeHtml(t.label)}</button>`
      ).join("");

      const panels = tabs.map(t => renderPanel(t.id, t.content, t.id === firstActive)).join("");
      const raw = `<details class="raw"><summary>Raw JSON 보기</summary><pre>${escapeHtml(JSON.stringify(detail || {}, null, 2))}</pre></details>`;

      return `
        <div class="tabs">
          <div class="tab-bar">${tabBtns}</div>
          <div class="tab-body">${panels}${raw}</div>
        </div>
      `;
    }

    function bindTabEvents() {
      const root = document.getElementById("modalBody");
      if (!root) return;
      root.onclick = (e) => {
        const btn = e.target.closest(".tab-btn");
        if (!btn) return;
        const tab = btn.dataset.tab;
        if (!tab) return;

        root.querySelectorAll(".tab-btn").forEach(b => b.classList.toggle("active", b.dataset.tab === tab));
        root.querySelectorAll(".tab-panel").forEach(p => p.classList.toggle("active", p.dataset.panel === tab));
      };
    }

    // ===== Modal =====
    const backdrop = document.getElementById("modalBackdrop");
    const modalBody = document.getElementById("modalBody");
    const modalTitle = document.getElementById("modalTitle");
    const modalClose = document.getElementById("modalClose");

    function openModal() {
      backdrop.classList.add("show");
      backdrop.setAttribute("aria-hidden", "false");
    }
    function closeModal() {
      backdrop.classList.remove("show");
      backdrop.setAttribute("aria-hidden", "true");
      modalBody.innerHTML = `<div class="modal-loading">Loading…</div>`;
    }
    modalClose.addEventListener("click", closeModal);
    backdrop.addEventListener("click", (e) => { if (e.target === backdrop) closeModal(); });
    document.addEventListener("keydown", (e) => { if (e.key === "Escape" && backdrop.classList.contains("show")) closeModal(); });

    // 중국어명 키가 무엇이든 이름 옆에 표시
    function setModalTitle(name, cn){
      const safeName = escapeHtml(name || "Character");
      const safeCn = cn ? escapeHtml(cn) : "";
      modalTitle.innerHTML = safeCn ? `${safeName}<span class="cn">${safeCn}</span>` : safeName;
    }

    async function fetchAndOpen(cid) {
      openModal();
      modalBody.innerHTML = `<div class="modal-loading">Loading…</div>`;
      try {
        const r = await fetch(`/zones/zone-nova/characters/${encodeURIComponent(cid)}`, { cache: "no-store" });
        const j = await r.json();
        if (!j.ok) {
          modalBody.innerHTML = `<div class="detail-empty">불러오기 실패: ${escapeHtml(j.error || "unknown")}</div>`;
          return;
        }

        const detail = j.detail || {};
        const name = pick(detail, "name") || j.character?.name || j.id || "Character";
        const cn = pick(detail, "chineseName", "chinesename", "chinessname", "cnName", "cn_name");

        setModalTitle(name, cn);
        modalBody.innerHTML = renderDetailTabs(detail);
        bindTabEvents();
      } catch (e) {
        modalBody.innerHTML = `<div class="detail-empty">불러오기 실패: ${escapeHtml(String(e))}</div>`;
      }
    }

    // ===== List Render =====
    const chars = dedupeById(CHARS_RAW || []);
    document.getElementById("sourceHint").textContent =
      "characters_ko/*.json (리스트/상세)";

    const $tbody = document.getElementById("tbody");
    const $q = document.getElementById("q");
    const $rarity = document.getElementById("rarityFilter");
    const $elem = document.getElementById("elemFilter");
    const $faction = document.getElementById("factionFilter");
    const $class = document.getElementById("classFilter");
    const $role = document.getElementById("roleFilter");

    function uniqSorted(values){
      return Array.from(new Set(values.filter(v => v && v !== "-")))
        .sort((a,b) => a.localeCompare(b));
    }

    function fillSelect(sel, values){
      for (const v of values){
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v;
        sel.appendChild(opt);
      }
    }

    fillSelect($elem, uniqSorted(chars.map(c => (c.element || "-"))));
    fillSelect($faction, uniqSorted(chars.map(c => (c.faction || "-"))));
    fillSelect($class, uniqSorted(chars.map(c => classLabel(c.class))));
    fillSelect($role, uniqSorted(chars.map(c => roleLabel(c.role))));

    function matchFilters(c){
      const q = ($q.value || "").trim().toLowerCase();
      const rarityV = ($rarity.value || "").trim().toUpperCase();
      const elemV = ($elem.value || "").trim();
      const factionV = ($faction.value || "").trim();
      const classV = ($class.value || "").trim();
      const roleV = ($role.value || "").trim();

      const name = (c.name || "").toString().toLowerCase();
      const id = (c.id || "").toString().toLowerCase();
      const faction = (c.faction || "-").toString().toLowerCase();
      const elem = (c.element || "-").toString();

      if (q){
        const ok = name.includes(q) || id.includes(q) || faction.includes(q) || elem.toLowerCase().includes(q);
        if (!ok) return false;
      }
      if (rarityV && (c.rarity || "-").toString().toUpperCase() !== rarityV) return false;
      if (elemV && (c.element || "-") !== elemV) return false;
      if (factionV && (c.faction || "-") !== factionV) return false;
      if (classV && classLabel(c.class) !== classV) return false;
      if (roleV && roleLabel(c.role) !== roleV) return false;

      return true;
    }

    function sortChars(list){
      return list.slice().sort((a,b) => {
        const ra = RARITY_ORDER[(a.rarity || "-").toString().toUpperCase()] ?? 0;
        const rb = RARITY_ORDER[(b.rarity || "-").toString().toUpperCase()] ?? 0;
        if (rb !== ra) return rb - ra;

        const na = (a.name || a.id || "").toString();
        const nb = (b.name || b.id || "").toString();
        return na.localeCompare(nb);
      });
    }

    function render(){
      const filtered = sortChars(chars.filter(matchFilters));
      const rows = filtered.map(c => {
        const cid = c.id;
        const nm = c.name || cid;

        const elem = (c.element || "-");
        const faction = (c.faction || "-");
        const cls = classLabel(c.class);
        const role = roleLabel(c.role);
        const rar = (c.rarity || "-").toString().toUpperCase();

        const elemIcon = c.element_icon ? `<img class="mini-icon" src="${escapeHtml(c.element_icon)}" alt="">` : "";
        const classIcon = c.class_icon ? `<img class="mini-icon" src="${escapeHtml(c.class_icon)}" alt="">` : "";

        const img = c.image
          ? `<img class="char-img" src="${escapeHtml(c.image)}" alt="">`
          : `<div class="char-img"></div>`;

        return `
          <tr>
            <td class="col-check"><input class="chk-owned" type="checkbox" data-cid="${escapeHtml(cid)}"></td>
            <td>
              <div class="char-cell clickable" data-cid="${escapeHtml(cid)}">
                ${img}
                <div class="char-name">${escapeHtml(nm)}</div>
              </div>
            </td>
            <td class="col-elem">
             <span class="pill pill-neutral pill-with-icon">
                ${elemIcon}
                <span class="pill-text">${escapeHtml(elem)}</span>
              </span>
            </td>
            <td class="col-faction"><span class="pill pill-neutral">${escapeHtml(faction)}</span></td>
            <td class="col-class">
              <span class="pill pill-neutral pill-with-icon">
                ${classIcon}
                <span class="pill-text">${escapeHtml(cls)}</span>
              </span>
            </td>
            <td class="col-role"><span class="pill pill-neutral">${escapeHtml(role)}</span></td>
            <td class="col-rarity"><span class="pill ${rarityPillClass(rar)}">${escapeHtml(rar)}</span></td>
          </tr>
        `;
      }).join("");

      $tbody.innerHTML = rows || `<tr><td colspan="7" style="padding:18px;color:rgba(255,255,255,.70);font-weight:800;">표시할 캐릭터가 없습니다.</td></tr>`;
    }

    [$q, $rarity, $elem, $faction, $class, $role].forEach(el => {
      el.addEventListener("input", render);
      el.addEventListener("change", render);
    });

    document.getElementById("btnAll").addEventListener("click", () => {
      document.querySelectorAll(".chk-owned").forEach(x => x.checked = true);
    });
    document.getElementById("btnNone").addEventListener("click", () => {
      document.querySelectorAll(".chk-owned").forEach(x => x.checked = false);
    });

    document.addEventListener("click", (e) => {
      const chk = e.target.closest(".chk-owned");
      if (chk) return;

      const cell = e.target.closest(".char-cell.clickable");
      if (!cell) return;

      const cid = cell.dataset.cid;
      if (cid) fetchAndOpen(cid);
    });
    
        // ===== Tier Party Builder (from tier-lists.js) =====
    let TIER_EXPORTS = null;          // import된 모듈 전체
    let TIER_PRESETS = [];            // export const 이름 목록
    let TIER_RANK_MAP = new Map();    // cid -> tierScore (선택된 프리셋 기준)
    
    // 점수: SSS > SS > S > A (나머지 0)
    const TIER_SCORE = { SSS: 4, SS: 3, S: 2, A: 1 };
    
    // 캐릭터 매칭(이름/ID)
    function buildCharIndex(chars){
      const byId = new Map();
      const byName = new Map();
      for (const c of (chars || [])){
        if (!c?.id) continue;
        byId.set(String(c.id).toLowerCase(), c.id);
        if (c.name) byName.set(String(c.name).toLowerCase(), c.id);
        if (c.raw_name) byName.set(String(c.raw_name).toLowerCase(), c.id);
      }
      return { byId, byName };
    }
    
    function normalizeTierRoot(obj){
      // tier 키를 가진 object를 찾아서 반환(1~2단계 탐색)
      if (!obj || typeof obj !== "object") return null;
    
      const keys = Object.keys(obj).map(k => k.toUpperCase());
      const hasTierKeys = (k) => ["SSS","SS","S","A"].includes(k);
      if (keys.some(hasTierKeys)) return obj;
    
      // 1단계 하위 탐색
      for (const v of Object.values(obj)){
        if (v && typeof v === "object" && !Array.isArray(v)){
          const k2 = Object.keys(v).map(k => k.toUpperCase());
          if (k2.some(hasTierKeys)) return v;
        }
      }
      return null;
    }
    
    function extractIdFromTierItem(x){
      // tier list 요소가 string or object일 수 있음
      if (x == null) return null;
      if (typeof x === "string") return x.trim();
      if (typeof x === "object"){
        const v = x.id || x.cid || x.key || x.name || x.character || x.unit;
        if (typeof v === "string") return v.trim();
      }
      return null;
    }
    
    function buildTierRankMapFromPreset(presetObj, chars){
      const root = normalizeTierRoot(presetObj);
      if (!root) return new Map();
    
      const { byId, byName } = buildCharIndex(chars);
    
      const map = new Map();
      for (const [k, list] of Object.entries(root)){
        const tier = String(k).toUpperCase();
        if (!TIER_SCORE[tier]) continue;
    
        const arr = Array.isArray(list) ? list : [];
        for (const item of arr){
          const raw = extractIdFromTierItem(item);
          if (!raw) continue;
    
          const key = raw.toLowerCase();
          const cid = byId.get(key) || byName.get(key) || null;
          if (!cid) continue;
    
          // 동일 캐릭터가 여러 tier에 있으면 더 높은 tier만 유지
          const prev = map.get(cid) || 0;
          map.set(cid, Math.max(prev, TIER_SCORE[tier]));
        }
      }
      return map;
    }
    
    function getOwnedSelectedIds(){
      // 기존 체크박스(.chk-owned) 기준
      const out = [];
      document.querySelectorAll(".chk-owned").forEach(chk => {
        if (chk.checked && chk.dataset.cid) out.push(chk.dataset.cid);
      });
      return out;
    }
    
    function getEnabledClassSet(){
      const use = document.getElementById("useClassFilter")?.checked;
      if (!use) return null;
    
      const picked = new Set();
      document.querySelectorAll(".tier-class-item input[type=checkbox]").forEach(x => {
        if (x.checked) picked.add(x.value);
      });
      return picked.size ? picked : null;
    }
    
    function hasComboSkill(party, charsById){
      // 콤보스킬 조건: 속성 2+ OR 특성 2+
      const elemCount = new Map();
      const facCount = new Map();
    
      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) continue;
        const e = (c.element || "-");
        const f = (c.faction || "-");
        elemCount.set(e, (elemCount.get(e) || 0) + 1);
        facCount.set(f, (facCount.get(f) || 0) + 1);
      }
      const maxElem = Math.max(0, ...elemCount.values());
      const maxFac = Math.max(0, ...facCount.values());
      return (maxElem >= 2) || (maxFac >= 2);
    }
    
    function partyScore(party, rankMap, charsById){
      // 티어 점수 합 + 콤보 보너스(약간)
      let sum = 0;
      for (const cid of party){
        sum += (rankMap.get(cid) || 0) * 100;
      }
    
      // 콤보 보너스(속성/특성 중복 많을수록 약간 가산)
      const elemCount = new Map();
      const facCount = new Map();
      for (const cid of party){
        const c = charsById.get(cid);
        if (!c) continue;
        const e = (c.element || "-");
        const f = (c.faction || "-");
        elemCount.set(e, (elemCount.get(e) || 0) + 1);
        facCount.set(f, (facCount.get(f) || 0) + 1);
      }
      const maxElem = Math.max(0, ...elemCount.values());
      const maxFac = Math.max(0, ...facCount.values());
      sum += (maxElem >= 2 ? 15 : 0);
      sum += (maxFac >= 2 ? 15 : 0);
      sum += (maxElem >= 3 ? 10 : 0);
      sum += (maxFac >= 3 ? 10 : 0);
    
      return sum;
    }
    
    function buildBestTierParty(){
      const owned = getOwnedSelectedIds();
      if (owned.length < 4){
        return { ok:false, msg:"보유 체크가 4명 이상이어야 합니다." };
      }
    
      const classSet = getEnabledClassSet();
    
      const charsById = new Map(chars.map(c => [c.id, c]));
      let candidates = owned.filter(cid => charsById.has(cid));
    
      // 클래스 필터 적용(선택된 클래스만 후보)
      if (classSet){
        candidates = candidates.filter(cid => {
          const cls = String(charsById.get(cid)?.class || "-");
          return classSet.has(cls);
        });
        if (candidates.length < 4){
          return { ok:false, msg:"클래스 필터 적용 결과 후보가 4명 미만입니다." };
        }
      }
    
      // 티어 점수로 후보 정렬
      candidates.sort((a,b) => (TIER_RANK_MAP.get(b) || 0) - (TIER_RANK_MAP.get(a) || 0));
    
      // 조합 폭 제한(너무 많으면 조합 수 폭증) - 상위 N명만으로 탐색
      const N = Math.min(28, candidates.length);
      const pool = candidates.slice(0, N);
    
      // 4인 조합 브루트포스(최대 C(28,4)=20475 → 브라우저에서 충분)
      let best = null;
      for (let i=0; i<pool.length-3; i++){
        for (let j=i+1; j<pool.length-2; j++){
          for (let k=j+1; k<pool.length-1; k++){
            for (let l=k+1; l<pool.length; l++){
              const party = [pool[i], pool[j], pool[k], pool[l]];
              if (!hasComboSkill(party, charsById)) continue;
    
              const sc = partyScore(party, TIER_RANK_MAP, charsById);
              if (!best || sc > best.score){
                best = { party, score: sc };
              }
            }
          }
        }
      }
    
      if (!best){
        return { ok:false, msg:"콤보스킬(속성 2+ 또는 특성 2+)을 만족하는 4인 조합을 찾지 못했습니다." };
      }
    
      return { ok:true, party: best.party };
    }
    
    function tierLabelFromScore(s){
      if (s === 4) return "SSS";
      if (s === 3) return "SS";
      if (s === 2) return "S";
      if (s === 1) return "A";
      return "-";
    }
    
    function renderTierPartyResult(res){
      const box = document.getElementById("tierPartyResult");
      if (!box) return;
    
      if (!res.ok){
        box.innerHTML = `<div class="tier-error">${escapeHtml(res.msg || "실패")}</div>`;
        return;
      }
    
      const charsById = new Map(chars.map(c => [c.id, c]));
      const rows = res.party.map(cid => {
        const c = charsById.get(cid);
        const tier = tierLabelFromScore(TIER_RANK_MAP.get(cid) || 0);
        const nm = c?.name || cid;
        const elem = c?.element || "-";
        const fac = c?.faction || "-";
        const cls = c?.class || "-";
    
        return `
          <div class="tier-card">
            <div class="tier-card-top">
              <span class="tier-badge tier-${tier.toLowerCase()}">${escapeHtml(tier)}</span>
              <span class="tier-name">${escapeHtml(nm)}</span>
            </div>
            <div class="tier-card-sub">
              <span class="pill pill-neutral">${escapeHtml(elem)}</span>
              <span class="pill pill-neutral">${escapeHtml(fac)}</span>
              <span class="pill pill-neutral">${escapeHtml(cls)}</span>
            </div>
          </div>
        `;
      }).join("");
    
      box.innerHTML = `<div class="tier-grid">${rows}</div>`;
    }
    
    function initTierClassCheckboxes(){
      const box = document.getElementById("tierClassBox");
      if (!box) return;
    
      // 화면에 있는 캐릭터 class 목록으로 생성
      const classes = Array.from(new Set(chars.map(c => String(c.class || "-")).filter(v => v && v !== "-")))
        .sort((a,b) => a.localeCompare(b));
    
      box.innerHTML = classes.map(cls => `
        <label class="tier-class-item">
          <input type="checkbox" value="${escapeHtml(cls)}" disabled>
          <span>${escapeHtml(cls)}</span>
        </label>
      `).join("");
    
      const use = document.getElementById("useClassFilter");
      const toggle = () => {
        const on = !!use.checked;
        box.setAttribute("aria-disabled", String(!on));
        box.querySelectorAll("input[type=checkbox]").forEach(x => x.disabled = !on);
      };
      use.addEventListener("change", toggle);
      toggle();
    }
    
    function initTierUI(){
      const sel = document.getElementById("tierPreset");
      const btn = document.getElementById("btnBuildTierParty");
      if (!sel || !btn) return;
    
      // export const 목록 뽑기(함수/기본값 제외)
      TIER_PRESETS = Object.keys(TIER_EXPORTS || {})
        .filter(k => k !== "default" && !k.startsWith("__"))
        .sort((a,b) => a.localeCompare(b));
    
      sel.innerHTML = `<option value="">등급표 선택</option>` + TIER_PRESETS.map(k =>
        `<option value="${escapeHtml(k)}">${escapeHtml(k)}</option>`
      ).join("");
    
      sel.disabled = false;
      btn.disabled = false;
    
      initTierClassCheckboxes();
    
      function applyPreset(){
        const key = sel.value;
        if (!key){
          TIER_RANK_MAP = new Map();
          return;
        }
        const presetObj = TIER_EXPORTS[key];
        TIER_RANK_MAP = buildTierRankMapFromPreset(presetObj, chars);
      }
    
      sel.addEventListener("change", () => {
        applyPreset();
        document.getElementById("tierPartyResult").innerHTML = "";
      });
    
      btn.addEventListener("click", () => {
        applyPreset();
        if (!sel.value){
          renderTierPartyResult({ ok:false, msg:"등급표를 먼저 선택하세요." });
          return;
        }
        const res = buildBestTierParty();
        renderTierPartyResult(res);
      });
    }

    
    render();

    window.addEventListener("tierlists:loaded", () => {
      TIER_EXPORTS = window.__TIER_EXPORTS__;
      initTierUI();
    });
    
  </script>
  <script type="module">
    import * as tiers from "/data/zone-nova/tier-lists.js";
    window.__TIER_EXPORTS__ = tiers;
    window.dispatchEvent(new Event("tierlists:loaded"));
  </script>

</body>
</html>
